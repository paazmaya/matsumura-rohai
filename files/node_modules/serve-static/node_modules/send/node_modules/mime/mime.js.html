<h1>mime</h1>
<pre><code class="lang-js"><span class="keyword">var</span> path = require(<span class="string">'path'</span>);
<span class="keyword">var</span> fs = require(<span class="string">'fs'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">Mime</span><span class="params">()</span> {</span>
  <span class="comment">// Map of extension -> mime type</span>
  <span class="keyword">this</span>.types = Object.create(<span class="literal">null</span>);

  <span class="comment">// Map of mime type -> extension</span>
  <span class="keyword">this</span>.extensions = Object.create(<span class="literal">null</span>);
}

<span class="comment">/**
 * Define mimetype -> extension mappings.  Each key is a mime-type that maps
 * to an array of extensions associated with the type.  The first extension is
 * used as the default extension for the type.
 *
 * e.g. mime.define({'audio/ogg', ['oga', 'ogg', 'spx']});
 *
 * @param map (Object) type definitions
 */</span>
Mime.prototype.define = <span class="function"><span class="keyword">function</span> <span class="params">(map)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> type <span class="keyword">in</span> map) {
    <span class="keyword">var</span> exts = map[type];

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; exts.length; i++) {
      <span class="keyword">if</span> (process.env.DEBUG_MIME &amp;&amp; <span class="keyword">this</span>.types[exts]) {
        console.warn(<span class="keyword">this</span>._loading.replace(<span class="regexp">/.*\//</span>, <span class="string">''</span>), <span class="string">'changes "'</span> + exts[i] + <span class="string">'" extension type from '</span> +
          <span class="keyword">this</span>.types[exts] + <span class="string">' to '</span> + type);
      }

      <span class="keyword">this</span>.types[exts[i]] = type;
    }

    <span class="comment">// Default extension is the first one we encounter</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.extensions[type]) {
      <span class="keyword">this</span>.extensions[type] = exts[<span class="number">0</span>];
    }
  }
};

<span class="comment">/**
 * Load an Apache2-style ".types" file
 *
 * This may be called multiple times (it's expected).  Where files declare
 * overlapping types/extensions, the last file wins.
 *
 * @param file (String) path of file to load.
 */</span>
Mime.prototype.load = <span class="keyword">function</span>(file) {

  <span class="keyword">this</span>._loading = file;
  <span class="comment">// Read file and split into lines</span>
  <span class="keyword">var</span> map = {},
      content = fs.readFileSync(file, <span class="string">'ascii'</span>),
      lines = content.split(<span class="regexp">/[\r\n]+/</span>);

  lines.forEach(<span class="keyword">function</span>(line) {
    <span class="comment">// Clean up whitespace/comments, and split into fields</span>
    <span class="keyword">var</span> fields = line.replace(<span class="regexp">/\s*#.*|^\s*|\s*$/g</span>, <span class="string">''</span>).split(<span class="regexp">/\s+/</span>);
    map[fields.shift()] = fields;
  });

  <span class="keyword">this</span>.define(map);

  <span class="keyword">this</span>._loading = <span class="literal">null</span>;
};

<span class="comment">/**
 * Lookup a mime type based on extension
 */</span>
Mime.prototype.lookup = <span class="keyword">function</span>(path, fallback) {
  <span class="keyword">var</span> ext = path.replace(<span class="regexp">/.*[\.\/\\]/</span>, <span class="string">''</span>).toLowerCase();

  <span class="keyword">return</span> <span class="keyword">this</span>.types[ext] || fallback || <span class="keyword">this</span>.default_type;
};

<span class="comment">/**
 * Return file extension associated with a mime type
 */</span>
Mime.prototype.extension = <span class="keyword">function</span>(mimeType) {
  <span class="keyword">var</span> type = mimeType.match(<span class="regexp">/^\s*([^;\s]*)(?:;|\s|$)/</span>)[<span class="number">1</span>].toLowerCase();
  <span class="keyword">return</span> <span class="keyword">this</span>.extensions[type];
};

<span class="comment">// Default instance</span>
<span class="keyword">var</span> mime = <span class="keyword">new</span> Mime();

<span class="comment">// Load local copy of</span>
<span class="comment">// http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types</span>
mime.load(path.join(__dirname, <span class="string">'types/mime.types'</span>));

<span class="comment">// Load additional types from node.js community</span>
mime.load(path.join(__dirname, <span class="string">'types/node.types'</span>));

<span class="comment">// Default type</span>
mime.default_type = mime.lookup(<span class="string">'bin'</span>);

<span class="comment">//</span>
<span class="comment">// Additional API specific to the default instance</span>
<span class="comment">//</span>

mime.Mime = Mime;

<span class="comment">/**
 * Lookup a charset based on mime type.
 */</span>
mime.charsets = {
  lookup: <span class="keyword">function</span>(mimeType, fallback) {
    <span class="comment">// Assume text types are utf8</span>
    <span class="keyword">return</span> (<span class="regexp">/^text\//</span>).test(mimeType) ? <span class="string">'UTF-8'</span> : fallback;
  }
};

module.exports = mime;
</code></pre>