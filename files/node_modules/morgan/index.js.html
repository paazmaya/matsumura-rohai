<h1>morgan</h1>
<pre><code class="lang-js"><span class="comment">/*!
 * morgan
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */</span>

<span class="comment">/**
 * Module dependencies.
 * @private
 */</span>

<span class="keyword">var</span> auth = require(<span class="string">'basic-auth'</span>)
<span class="keyword">var</span> debug = require(<span class="string">'debug'</span>)(<span class="string">'morgan'</span>)
<span class="keyword">var</span> deprecate = require(<span class="string">'depd'</span>)(<span class="string">'morgan'</span>)
<span class="keyword">var</span> onFinished = require(<span class="string">'on-finished'</span>)

<span class="comment">/**
 * Default log buffer duration.
 * @private
 */</span>

<span class="keyword">var</span> defaultBufferDuration = <span class="number">1000</span>;

<span class="comment">/**
 * Create a logger middleware.
 *
 * @public
 * @param {String|Function} format
 * @param {Object} [options]
 * @return {Function} middleware
 */</span>

exports = module.exports = <span class="function"><span class="keyword">function</span> <span class="title">morgan</span><span class="params">(format, options)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> format === <span class="string">'object'</span>) {
    options = format
    format = options.format || <span class="string">'default'</span>

    <span class="comment">// smart deprecation message</span>
    deprecate(<span class="string">'morgan(options): use morgan('</span> + (<span class="keyword">typeof</span> format === <span class="string">'string'</span> ? JSON.stringify(format) : <span class="string">'format'</span>) + <span class="string">', options) instead'</span>)
  }

  <span class="keyword">if</span> (format === <span class="literal">undefined</span>) {
    deprecate(<span class="string">'undefined format: specify a format'</span>)
  }

  options = options || {}

  <span class="comment">// output on request instead of response</span>
  <span class="keyword">var</span> immediate = options.immediate;

  <span class="comment">// check if log entry should be skipped</span>
  <span class="keyword">var</span> skip = options.skip || <span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span> <span class="keyword">return</span> <span class="literal">false</span>; };

  <span class="comment">// format function</span>
  <span class="keyword">var</span> fmt = compile(exports[format] || format || exports.<span class="keyword">default</span>)

  <span class="comment">// options</span>
  <span class="keyword">var</span> stream = options.stream || process.stdout
    , buffer = options.buffer;

  <span class="comment">// buffering support</span>
  <span class="keyword">if</span> (buffer) {
    <span class="keyword">var</span> realStream = stream
    <span class="keyword">var</span> buf = []
    <span class="keyword">var</span> timer = <span class="literal">null</span>
    <span class="keyword">var</span> interval = <span class="string">'number'</span> == <span class="keyword">typeof</span> buffer
      ? buffer
      : defaultBufferDuration

    <span class="comment">// flush function</span>
    <span class="keyword">var</span> flush = <span class="keyword">function</span>(){
      timer = <span class="literal">null</span>

      <span class="keyword">if</span> (buf.length) {
        realStream.write(buf.join(<span class="string">''</span>));
        buf.length = <span class="number">0</span>;
      }
    }

    <span class="comment">// swap the stream</span>
    stream = {
      write: <span class="keyword">function</span>(str){
        <span class="keyword">if</span> (timer === <span class="literal">null</span>) {
          timer = setTimeout(flush, interval)
        }

        buf.push(str);
      }
    };
  }

  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">logger</span><span class="params">(req, res, next)</span> {</span>
    req._startAt = process.hrtime();
    req._startTime = <span class="keyword">new</span> Date;
    req._remoteAddress = getip(req);

    <span class="function"><span class="keyword">function</span> <span class="title">logRequest</span><span class="params">()</span>{</span>
      <span class="keyword">if</span> (skip(req, res)) {
        debug(<span class="string">'skip request'</span>)
        <span class="keyword">return</span>
      }

      <span class="keyword">var</span> line = fmt(exports, req, res)

      <span class="keyword">if</span> (<span class="literal">null</span> == line) {
        debug(<span class="string">'skip line'</span>)
        <span class="keyword">return</span>
      }

      debug(<span class="string">'log request'</span>)
      stream.write(line + <span class="string">'\n'</span>)
    };

    <span class="comment">// immediate</span>
    <span class="keyword">if</span> (immediate) {
      logRequest();
    } <span class="keyword">else</span> {
      onFinished(res, logRequest)
    }

    next();
  };
};

<span class="comment">/**
 * Compile `format` into a function.
 *
 * @private
 * @param {Function|String} format
 * @return {Function}
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">compile</span><span class="params">(format)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> format === <span class="string">'function'</span>) {
    <span class="comment">// already compiled</span>
    <span class="keyword">return</span> format
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> format !== <span class="string">'string'</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'argument format must be a function or string'</span>)
  }

  <span class="keyword">var</span> fmt = format.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>)
  <span class="keyword">var</span> js = <span class="string">'  return "'</span> + fmt.replace(<span class="regexp">/:([-\w]{2,})(?:\[([^\]]+)\])?/g</span>, <span class="keyword">function</span>(_, name, arg){
    <span class="keyword">return</span> <span class="string">'"\n    + (tokens["'</span> + name + <span class="string">'"](req, res, "'</span> + arg + <span class="string">'") || "-") + "'</span>;
  }) + <span class="string">'";'</span>

  <span class="keyword">return</span> <span class="keyword">new</span> Function(<span class="string">'tokens, req, res'</span>, js);
};

<span class="comment">/**
 * Define a token function with the given `name`,
 * and callback `fn(req, res)`.
 *
 * @public
 * @param {String} name
 * @param {Function} fn
 * @return {Object} exports for chaining
 */</span>

exports.token = <span class="keyword">function</span>(name, fn) {
  exports[name] = fn;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Define a `fmt` with the given `name`.
 *
 * @public
 * @param {String} name
 * @param {String|Function} fmt
 * @return {Object} exports for chaining
 */</span>

exports.format = <span class="keyword">function</span>(name, fmt){
  exports[name] = fmt;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Apache combined log format.
 */</span>

exports.format(<span class="string">'combined'</span>, <span class="string">':remote-addr - :remote-user [:date] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"'</span>)

<span class="comment">/**
 * Apache common log format.
 */</span>

exports.format(<span class="string">'common'</span>, <span class="string">':remote-addr - :remote-user [:date] ":method :url HTTP/:http-version" :status :res[content-length]'</span>)

<span class="comment">/**
 * Default format.
 */</span>

exports.format(<span class="string">'default'</span>, <span class="string">':remote-addr - :remote-user [:date] ":method :url HTTP/:http-version" :status :res[content-length] ":referrer" ":user-agent"'</span>);
deprecate.property(exports, <span class="string">'default'</span>, <span class="string">'default format: use combined format'</span>)

<span class="comment">/**
 * Short format.
 */</span>

exports.format(<span class="string">'short'</span>, <span class="string">':remote-addr :remote-user :method :url HTTP/:http-version :status :res[content-length] - :response-time ms'</span>);

<span class="comment">/**
 * Tiny format.
 */</span>

exports.format(<span class="string">'tiny'</span>, <span class="string">':method :url :status :res[content-length] - :response-time ms'</span>);

<span class="comment">/**
 * dev (colored)
 */</span>

exports.format(<span class="string">'dev'</span>, <span class="keyword">function</span>(tokens, req, res){
  <span class="keyword">var</span> color = <span class="number">32</span>; <span class="comment">// green</span>
  <span class="keyword">var</span> status = res.statusCode;

  <span class="keyword">if</span> (status >= <span class="number">500</span>) color = <span class="number">31</span>; <span class="comment">// red</span>
  <span class="keyword">else</span> <span class="keyword">if</span> (status >= <span class="number">400</span>) color = <span class="number">33</span>; <span class="comment">// yellow</span>
  <span class="keyword">else</span> <span class="keyword">if</span> (status >= <span class="number">300</span>) color = <span class="number">36</span>; <span class="comment">// cyan</span>

  <span class="keyword">var</span> fn = compile(<span class="string">'\x1b[0m:method :url \x1b['</span> + color + <span class="string">'m:status \x1b[0m:response-time ms - :res[content-length]\x1b[0m'</span>);

  <span class="keyword">return</span> fn(tokens, req, res);
});

<span class="comment">/**
 * request url
 */</span>

exports.token(<span class="string">'url'</span>, <span class="keyword">function</span>(req){
  <span class="keyword">return</span> req.originalUrl || req.url;
});

<span class="comment">/**
 * request method
 */</span>

exports.token(<span class="string">'method'</span>, <span class="keyword">function</span>(req){
  <span class="keyword">return</span> req.method;
});

<span class="comment">/**
 * response time in milliseconds
 */</span>

exports.token(<span class="string">'response-time'</span>, <span class="keyword">function</span>(req, res){
  <span class="keyword">if</span> (!res._header || !req._startAt) <span class="keyword">return</span> <span class="string">''</span>;
  <span class="keyword">var</span> diff = process.hrtime(req._startAt);
  <span class="keyword">var</span> ms = diff[<span class="number">0</span>] * <span class="number">1e3</span> + diff[<span class="number">1</span>] * <span class="number">1e-6</span>;
  <span class="keyword">return</span> ms.toFixed(<span class="number">3</span>);
});

<span class="comment">/**
 * UTC date
 */</span>

exports.token(<span class="string">'date'</span>, <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="keyword">new</span> Date().toUTCString();
});

<span class="comment">/**
 * response status code
 */</span>

exports.token(<span class="string">'status'</span>, <span class="keyword">function</span>(req, res){
  <span class="keyword">return</span> res._header ? res.statusCode : <span class="literal">null</span>;
});

<span class="comment">/**
 * normalized referrer
 */</span>

exports.token(<span class="string">'referrer'</span>, <span class="keyword">function</span>(req){
  <span class="keyword">return</span> req.headers[<span class="string">'referer'</span>] || req.headers[<span class="string">'referrer'</span>];
});

<span class="comment">/**
 * remote address
 */</span>

exports.token(<span class="string">'remote-addr'</span>, getip);

<span class="comment">/**
 * remote user
 */</span>

exports.token(<span class="string">'remote-user'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req)</span> {</span>
  <span class="keyword">var</span> creds = auth(req)
  <span class="keyword">var</span> user = (creds &amp;&amp; creds.name) || <span class="string">'-'</span>
  <span class="keyword">return</span> user;
})

<span class="comment">/**
 * HTTP version
 */</span>

exports.token(<span class="string">'http-version'</span>, <span class="keyword">function</span>(req){
  <span class="keyword">return</span> req.httpVersionMajor + <span class="string">'.'</span> + req.httpVersionMinor;
});

<span class="comment">/**
 * UA string
 */</span>

exports.token(<span class="string">'user-agent'</span>, <span class="keyword">function</span>(req){
  <span class="keyword">return</span> req.headers[<span class="string">'user-agent'</span>];
});

<span class="comment">/**
 * request header
 */</span>

exports.token(<span class="string">'req'</span>, <span class="keyword">function</span>(req, res, field){
  <span class="keyword">return</span> req.headers[field.toLowerCase()];
});

<span class="comment">/**
 * response header
 */</span>

exports.token(<span class="string">'res'</span>, <span class="keyword">function</span>(req, res, field){
  <span class="keyword">return</span> (res._headers || {})[field.toLowerCase()];
});

<span class="comment">/**
 * Get request IP address.
 *
 * @private
 * @param {IncomingMessage} req
 * @return {string}
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">getip</span><span class="params">(req)</span> {</span>
  <span class="keyword">return</span> req.ip
    || req._remoteAddress
    || (req.connection &amp;&amp; req.connection.remoteAddress)
    || <span class="literal">undefined</span>;
}
</code></pre>