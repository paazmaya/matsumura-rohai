<h1>debug.js</h1>
<pre><code class="lang-js"><span class="comment">/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */</span>

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require(<span class="string">'ms'</span>);

<span class="comment">/**
 * The currently active debug mode names, and names to skip.
 */</span>

exports.names = [];
exports.skips = [];

<span class="comment">/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */</span>

exports.formatters = {};

<span class="comment">/**
 * Previously assigned color.
 */</span>

<span class="keyword">var</span> prevColor = <span class="number">0</span>;

<span class="comment">/**
 * Previous log timestamp.
 */</span>

<span class="keyword">var</span> prevTime;

<span class="comment">/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">selectColor</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> exports.colors[prevColor++ % exports.colors.length];
}

<span class="comment">/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">debug</span><span class="params">(namespace)</span> {</span>

  <span class="comment">// define the `disabled` version</span>
  <span class="function"><span class="keyword">function</span> <span class="title">disabled</span><span class="params">()</span> {</span>
  }
  disabled.enabled = <span class="literal">false</span>;

  <span class="comment">// define the `enabled` version</span>
  <span class="function"><span class="keyword">function</span> <span class="title">enabled</span><span class="params">()</span> {</span>

    <span class="keyword">var</span> self = enabled;

    <span class="comment">// set `diff` timestamp</span>
    <span class="keyword">var</span> curr = +<span class="keyword">new</span> Date();
    <span class="keyword">var</span> ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    <span class="comment">// add the `color` if not set</span>
    <span class="keyword">if</span> (<span class="literal">null</span> == self.useColors) self.useColors = exports.useColors();
    <span class="keyword">if</span> (<span class="literal">null</span> == self.color &amp;&amp; self.useColors) self.color = selectColor();

    <span class="keyword">var</span> args = Array.prototype.slice.call(arguments);

    args[<span class="number">0</span>] = exports.coerce(args[<span class="number">0</span>]);

    <span class="keyword">if</span> (<span class="string">'string'</span> !== <span class="keyword">typeof</span> args[<span class="number">0</span>]) {
      <span class="comment">// anything else let's inspect with %o</span>
      args = [<span class="string">'%o'</span>].concat(args);
    }

    <span class="comment">// apply any `formatters` transformations</span>
    <span class="keyword">var</span> index = <span class="number">0</span>;
    args[<span class="number">0</span>] = args[<span class="number">0</span>].replace(<span class="regexp">/%([a-z%])/g</span>, <span class="keyword">function</span>(match, format) {
      <span class="comment">// if we encounter an escaped % then don't increase the array index</span>
      <span class="keyword">if</span> (match === <span class="string">'%%'</span>) <span class="keyword">return</span> match;
      index++;
      <span class="keyword">var</span> formatter = exports.formatters[format];
      <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> formatter) {
        <span class="keyword">var</span> val = args[index];
        match = formatter.call(self, val);

        <span class="comment">// now we need to remove `args[index]` since it's inlined in the `format`</span>
        args.splice(index, <span class="number">1</span>);
        index--;
      }
      <span class="keyword">return</span> match;
    });

    <span class="keyword">if</span> (<span class="string">'function'</span> === <span class="keyword">typeof</span> exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    <span class="keyword">var</span> logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = <span class="literal">true</span>;

  <span class="keyword">var</span> fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  <span class="keyword">return</span> fn;
}

<span class="comment">/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">enable</span><span class="params">(namespaces)</span> {</span>
  exports.save(namespaces);

  <span class="keyword">var</span> split = (namespaces || <span class="string">''</span>).split(<span class="regexp">/[\s,]+/</span>);
  <span class="keyword">var</span> len = split.length;

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) {
    <span class="keyword">if</span> (!split[i]) <span class="keyword">continue</span>; <span class="comment">// ignore empty strings</span>
    namespaces = split[i].replace(<span class="regexp">/\*/g</span>, <span class="string">'.*?'</span>);
    <span class="keyword">if</span> (namespaces[<span class="number">0</span>] === <span class="string">'-'</span>) {
      exports.skips.push(<span class="keyword">new</span> RegExp(<span class="string">'^'</span> + namespaces.substr(<span class="number">1</span>) + <span class="string">'$'</span>));
    } <span class="keyword">else</span> {
      exports.names.push(<span class="keyword">new</span> RegExp(<span class="string">'^'</span> + namespaces + <span class="string">'$'</span>));
    }
  }
}

<span class="comment">/**
 * Disable debug output.
 *
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">disable</span><span class="params">()</span> {</span>
  exports.enable(<span class="string">''</span>);
}

<span class="comment">/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">enabled</span><span class="params">(name)</span> {</span>
  <span class="keyword">var</span> i, len;
  <span class="keyword">for</span> (i = <span class="number">0</span>, len = exports.skips.length; i &lt; len; i++) {
    <span class="keyword">if</span> (exports.skips[i].test(name)) {
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
  }
  <span class="keyword">for</span> (i = <span class="number">0</span>, len = exports.names.length; i &lt; len; i++) {
    <span class="keyword">if</span> (exports.names[i].test(name)) {
      <span class="keyword">return</span> <span class="literal">true</span>;
    }
  }
  <span class="keyword">return</span> <span class="literal">false</span>;
}

<span class="comment">/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">coerce</span><span class="params">(val)</span> {</span>
  <span class="keyword">if</span> (val <span class="keyword">instanceof</span> Error) <span class="keyword">return</span> val.stack || val.message;
  <span class="keyword">return</span> val;
}
</code></pre>