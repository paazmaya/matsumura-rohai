<h1>index.js</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Module dependencies.
 */</span>

<span class="keyword">var</span> Route = require(<span class="string">'./route'</span>);
<span class="keyword">var</span> Layer = require(<span class="string">'./layer'</span>);
<span class="keyword">var</span> methods = require(<span class="string">'methods'</span>);
<span class="keyword">var</span> mixin = require(<span class="string">'utils-merge'</span>);
<span class="keyword">var</span> debug = require(<span class="string">'debug'</span>)(<span class="string">'express:router'</span>);
<span class="keyword">var</span> parseUrl = require(<span class="string">'parseurl'</span>);
<span class="keyword">var</span> utils = require(<span class="string">'../utils'</span>);

<span class="comment">/**
 * Module variables.
 */</span>

<span class="keyword">var</span> objectRegExp = <span class="regexp">/^\[object (\S+)\]$/</span>;
<span class="keyword">var</span> slice = Array.prototype.slice;
<span class="keyword">var</span> toString = Object.prototype.toString;

<span class="comment">/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} options
 * @return {Router} which is an callable function
 * @api public
 */</span>

<span class="keyword">var</span> proto = module.exports = <span class="keyword">function</span>(options) {
  options = options || {};

  <span class="function"><span class="keyword">function</span> <span class="title">router</span><span class="params">(req, res, next)</span> {</span>
    router.handle(req, res, next);
  }

  <span class="comment">// mixin Router class functions</span>
  router.__proto__ = proto;

  router.params = {};
  router._params = [];
  router.caseSensitive = options.caseSensitive;
  router.mergeParams = options.mergeParams;
  router.strict = options.strict;
  router.stack = [];

  <span class="keyword">return</span> router;
};

<span class="comment">/**
 * Map the given param placeholder `name`(s) to the given callback.
 *
 * Parameter mapping is used to provide pre-conditions to routes
 * which use normalized placeholders. For example a _:user_id_ parameter
 * could automatically load a user's information from the database without
 * any additional code,
 *
 * The callback uses the same signature as middleware, the only difference
 * being that the value of the placeholder is passed, in this case the _id_
 * of the user. Once the `next()` function is invoked, just like middleware
 * it will continue on to execute the route, or subsequent parameter functions.
 *
 * Just like in middleware, you must either respond to the request or call next
 * to avoid stalling the request.
 *
 *  app.param('user_id', function(req, res, next, id){
 *    User.find(id, function(err, user){
 *      if (err) {
 *        return next(err);
 *      } else if (!user) {
 *        return next(new Error('failed to load user'));
 *      }
 *      req.user = user;
 *      next();
 *    });
 *  });
 *
 * @param {String} name
 * @param {Function} fn
 * @return {app} for chaining
 * @api public
 */</span>

proto.param = <span class="keyword">function</span>(name, fn){
  <span class="comment">// param logic</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> name) {
    <span class="keyword">this</span>._params.push(name);
    <span class="keyword">return</span>;
  }

  <span class="comment">// apply param functions</span>
  <span class="keyword">var</span> params = <span class="keyword">this</span>._params;
  <span class="keyword">var</span> len = params.length;
  <span class="keyword">var</span> ret;

  <span class="keyword">if</span> (name[<span class="number">0</span>] === <span class="string">':'</span>) {
    name = name.substr(<span class="number">1</span>);
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i) {
    <span class="keyword">if</span> (ret = params[i](name, fn)) {
      fn = ret;
    }
  }

  <span class="comment">// ensure we end up with a</span>
  <span class="comment">// middleware function</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> != <span class="keyword">typeof</span> fn) {
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'invalid param() call for '</span> + name + <span class="string">', got '</span> + fn);
  }

  (<span class="keyword">this</span>.params[name] = <span class="keyword">this</span>.params[name] || []).push(fn);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Dispatch a req, res into the router.
 *
 * @api private
 */</span>

proto.handle = <span class="keyword">function</span>(req, res, done) {
  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  debug(<span class="string">'dispatching %s %s'</span>, req.method, req.url);

  <span class="keyword">var</span> search = <span class="number">1</span> + req.url.indexOf(<span class="string">'?'</span>);
  <span class="keyword">var</span> pathlength = search ? search - <span class="number">1</span> : req.url.length;
  <span class="keyword">var</span> fqdn = <span class="number">1</span> + req.url.substr(<span class="number">0</span>, pathlength).indexOf(<span class="string">'://'</span>);
  <span class="keyword">var</span> protohost = fqdn ? req.url.substr(<span class="number">0</span>, req.url.indexOf(<span class="string">'/'</span>, <span class="number">2</span> + fqdn)) : <span class="string">''</span>;
  <span class="keyword">var</span> idx = <span class="number">0</span>;
  <span class="keyword">var</span> removed = <span class="string">''</span>;
  <span class="keyword">var</span> slashAdded = <span class="literal">false</span>;
  <span class="keyword">var</span> paramcalled = {};

  <span class="comment">// store options for OPTIONS request</span>
  <span class="comment">// only used if OPTIONS request</span>
  <span class="keyword">var</span> options = [];

  <span class="comment">// middleware and routes</span>
  <span class="keyword">var</span> stack = self.stack;

  <span class="comment">// manage inter-router variables</span>
  <span class="keyword">var</span> parentParams = req.params;
  <span class="keyword">var</span> parentUrl = req.baseUrl || <span class="string">''</span>;
  done = restore(done, req, <span class="string">'baseUrl'</span>, <span class="string">'next'</span>, <span class="string">'params'</span>);

  <span class="comment">// setup next layer</span>
  req.next = next;

  <span class="comment">// for options requests, respond with a default if nothing else responds</span>
  <span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) {
    done = wrap(done, <span class="keyword">function</span>(old, err) {
      <span class="keyword">if</span> (err || options.length === <span class="number">0</span>) <span class="keyword">return</span> old(err);

      <span class="keyword">var</span> body = options.join(<span class="string">','</span>);
      <span class="keyword">return</span> res.set(<span class="string">'Allow'</span>, body).send(body);
    });
  }

  <span class="comment">// setup basic req values</span>
  req.baseUrl = parentUrl;
  req.originalUrl = req.originalUrl || req.url;

  next();

  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err)</span> {</span>
    <span class="keyword">var</span> layerError = err === <span class="string">'route'</span>
      ? <span class="literal">null</span>
      : err;

    <span class="keyword">var</span> layer = stack[idx++];

    <span class="keyword">if</span> (slashAdded) {
      req.url = req.url.substr(<span class="number">1</span>);
      slashAdded = <span class="literal">false</span>;
    }

    <span class="keyword">if</span> (removed.length !== <span class="number">0</span>) {
      req.baseUrl = parentUrl;
      req.url = protohost + removed + req.url.substr(protohost.length);
      removed = <span class="string">''</span>;
    }

    <span class="keyword">if</span> (!layer) {
      <span class="keyword">return</span> done(layerError);
    }

    self.match_layer(layer, req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err, path)</span> {</span>
      <span class="keyword">if</span> (err || path === <span class="literal">undefined</span>) {
        <span class="keyword">return</span> next(layerError || err);
      }

      <span class="comment">// route object and not middleware</span>
      <span class="keyword">var</span> route = layer.route;

      <span class="comment">// if final route, then we support options</span>
      <span class="keyword">if</span> (route) {
        <span class="comment">// we don't run any routes with error first</span>
        <span class="keyword">if</span> (layerError) {
          <span class="keyword">return</span> next(layerError);
        }

        <span class="keyword">var</span> method = req.method;
        <span class="keyword">var</span> has_method = route._handles_method(method);

        <span class="comment">// build up automatic options response</span>
        <span class="keyword">if</span> (!has_method &amp;&amp; method === <span class="string">'OPTIONS'</span>) {
          options.push.apply(options, route._options());
        }

        <span class="comment">// don't even bother</span>
        <span class="keyword">if</span> (!has_method &amp;&amp; method !== <span class="string">'HEAD'</span>) {
          <span class="keyword">return</span> next();
        }

        <span class="comment">// we can now dispatch to the route</span>
        req.route = route;
      }

      <span class="comment">// Capture one-time layer values</span>
      req.params = self.mergeParams
        ? mergeParams(layer.params, parentParams)
        : layer.params;
      <span class="keyword">var</span> layerPath = layer.path;

      <span class="comment">// this should be done for the layer</span>
      self.process_params(layer, paramcalled, req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
        <span class="keyword">if</span> (err) {
          <span class="keyword">return</span> next(layerError || err);
        }

        <span class="keyword">if</span> (route) {
          <span class="keyword">return</span> layer.handle_request(req, res, next);
        }

        trim_prefix(layer, layerError, layerPath, path);
      });
    });
  }

  <span class="function"><span class="keyword">function</span> <span class="title">trim_prefix</span><span class="params">(layer, layerError, layerPath, path)</span> {</span>
    <span class="keyword">var</span> c = path[layerPath.length];
    <span class="keyword">if</span> (c &amp;&amp; <span class="string">'/'</span> !== c &amp;&amp; <span class="string">'.'</span> !== c) <span class="keyword">return</span> next(layerError);

     <span class="comment">// Trim off the part of the url that matches the route</span>
     <span class="comment">// middleware (.use stuff) needs to have the path stripped</span>
    <span class="keyword">if</span> (layerPath.length !== <span class="number">0</span>) {
      debug(<span class="string">'trim prefix (%s) from url %s'</span>, layerPath, req.url);
      removed = layerPath;
      req.url = protohost + req.url.substr(protohost.length + removed.length);

      <span class="comment">// Ensure leading slash</span>
      <span class="keyword">if</span> (!fqdn &amp;&amp; req.url[<span class="number">0</span>] !== <span class="string">'/'</span>) {
        req.url = <span class="string">'/'</span> + req.url;
        slashAdded = <span class="literal">true</span>;
      }

      <span class="comment">// Setup base URL (no trailing slash)</span>
      req.baseUrl = parentUrl + (removed[removed.length - <span class="number">1</span>] === <span class="string">'/'</span>
        ? removed.substring(<span class="number">0</span>, removed.length - <span class="number">1</span>)
        : removed);
    }

    debug(<span class="string">'%s %s : %s'</span>, layer.name, layerPath, req.originalUrl);

    <span class="keyword">if</span> (layerError) {
      layer.handle_error(layerError, req, res, next);
    } <span class="keyword">else</span> {
      layer.handle_request(req, res, next);
    }
  }
};

<span class="comment">/**
 * Match request to a layer.
 *
 * @api private
 */</span>

proto.match_layer = <span class="function"><span class="keyword">function</span> <span class="title">match_layer</span><span class="params">(layer, req, res, done)</span> {</span>
  <span class="keyword">var</span> error = <span class="literal">null</span>;
  <span class="keyword">var</span> path;

  <span class="keyword">try</span> {
    path = parseUrl(req).pathname;

    <span class="keyword">if</span> (!layer.match(path)) {
      path = <span class="literal">undefined</span>;
    }
  } <span class="keyword">catch</span> (err) {
    error = err;
  }

  done(error, path);
};

<span class="comment">/**
 * Process any parameters for the layer.
 *
 * @api private
 */</span>

proto.process_params = <span class="keyword">function</span>(layer, called, req, res, done) {
  <span class="keyword">var</span> params = <span class="keyword">this</span>.params;

  <span class="comment">// captured parameters from the layer, keys and values</span>
  <span class="keyword">var</span> keys = layer.keys;

  <span class="comment">// fast track</span>
  <span class="keyword">if</span> (!keys || keys.length === <span class="number">0</span>) {
    <span class="keyword">return</span> done();
  }

  <span class="keyword">var</span> i = <span class="number">0</span>;
  <span class="keyword">var</span> name;
  <span class="keyword">var</span> paramIndex = <span class="number">0</span>;
  <span class="keyword">var</span> key;
  <span class="keyword">var</span> paramVal;
  <span class="keyword">var</span> paramCallbacks;
  <span class="keyword">var</span> paramCalled;

  <span class="comment">// process params in order</span>
  <span class="comment">// param callbacks can be async</span>
  <span class="function"><span class="keyword">function</span> <span class="title">param</span><span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (err) {
      <span class="keyword">return</span> done(err);
    }

    <span class="keyword">if</span> (i >= keys.length ) {
      <span class="keyword">return</span> done();
    }

    paramIndex = <span class="number">0</span>;
    key = keys[i++];

    <span class="keyword">if</span> (!key) {
      <span class="keyword">return</span> done();
    }

    name = key.name;
    paramVal = req.params[name];
    paramCallbacks = params[name];
    paramCalled = called[name];

    <span class="keyword">if</span> (paramVal === <span class="literal">undefined</span> || !paramCallbacks) {
      <span class="keyword">return</span> param();
    }

    <span class="comment">// param previously called with same value or error occurred</span>
    <span class="keyword">if</span> (paramCalled &amp;&amp; (paramCalled.error || paramCalled.match === paramVal)) {
      <span class="comment">// restore value</span>
      req.params[name] = paramCalled.value;

      <span class="comment">// next param</span>
      <span class="keyword">return</span> param(paramCalled.error);
    }

    called[name] = paramCalled = {
      error: <span class="literal">null</span>,
      match: paramVal,
      value: paramVal
    };

    paramCallback();
  }

  <span class="comment">// single param callbacks</span>
  <span class="function"><span class="keyword">function</span> <span class="title">paramCallback</span><span class="params">(err)</span> {</span>
    <span class="keyword">var</span> fn = paramCallbacks[paramIndex++];

    <span class="comment">// store updated value</span>
    paramCalled.value = req.params[key.name];

    <span class="keyword">if</span> (err) {
      <span class="comment">// store error</span>
      paramCalled.error = err;
      param(err);
      <span class="keyword">return</span>;
    }

    <span class="keyword">if</span> (!fn) <span class="keyword">return</span> param();

    <span class="keyword">try</span> {
      fn(req, res, paramCallback, paramVal, key.name);
    } <span class="keyword">catch</span> (e) {
      paramCallback(e);
    }
  }

  param();
};

<span class="comment">/**
 * Use the given middleware function, with optional path, defaulting to "/".
 *
 * Use (like `.all`) will run for any http METHOD, but it will not add
 * handlers for those methods so OPTIONS requests will not consider `.use`
 * functions even if they could respond.
 *
 * The other difference is that _route_ path is stripped and not visible
 * to the handler function. The main effect of this feature is that mounted
 * handlers can operate without any code changes regardless of the "prefix"
 * pathname.
 *
 * @api public
 */</span>

proto.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span><span class="params">(fn)</span> {</span>
  <span class="keyword">var</span> offset = <span class="number">0</span>;
  <span class="keyword">var</span> path = <span class="string">'/'</span>;
  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="comment">// default path to '/'</span>
  <span class="comment">// disambiguate router.use([fn])</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) {
    <span class="keyword">var</span> arg = fn;

    <span class="keyword">while</span> (Array.isArray(arg) &amp;&amp; arg.length !== <span class="number">0</span>) {
      arg = arg[<span class="number">0</span>];
    }

    <span class="comment">// first arg is the path</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'function'</span>) {
      offset = <span class="number">1</span>;
      path = fn;
    }
  }

  <span class="keyword">var</span> callbacks = utils.flatten(slice.call(arguments, offset));

  <span class="keyword">if</span> (callbacks.length === <span class="number">0</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Router.use() requires middleware functions'</span>);
  }

  callbacks.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'Router.use() requires middleware function but got a '</span> + gettype(fn));
    }

    <span class="comment">// add the middleware</span>
    debug(<span class="string">'use %s %s'</span>, path, fn.name || <span class="string">'&lt;anonymous>'</span>);

    <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, {
      sensitive: self.caseSensitive,
      strict: <span class="literal">false</span>,
      end: <span class="literal">false</span>
    }, fn);

    layer.route = <span class="literal">undefined</span>;

    self.stack.push(layer);
  });

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Create a new Route for the given path.
 *
 * Each route contains a separate middleware stack and VERB handlers.
 *
 * See the Route api documentation for details on adding handlers
 * and middleware to routes.
 *
 * @param {String} path
 * @return {Route}
 * @api public
 */</span>

proto.route = <span class="keyword">function</span>(path){
  <span class="keyword">var</span> route = <span class="keyword">new</span> Route(path);

  <span class="keyword">var</span> layer = <span class="keyword">new</span> Layer(path, {
    sensitive: <span class="keyword">this</span>.caseSensitive,
    strict: <span class="keyword">this</span>.strict,
    end: <span class="literal">true</span>
  }, route.dispatch.bind(route));

  layer.route = route;

  <span class="keyword">this</span>.stack.push(layer);
  <span class="keyword">return</span> route;
};

<span class="comment">// create Router#VERB functions</span>
methods.concat(<span class="string">'all'</span>).forEach(<span class="keyword">function</span>(method){
  proto[method] = <span class="keyword">function</span>(path){
    <span class="keyword">var</span> route = <span class="keyword">this</span>.route(path)
    route[method].apply(route, slice.call(arguments, <span class="number">1</span>));
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };
});

<span class="comment">// get type for error message</span>
<span class="function"><span class="keyword">function</span> <span class="title">gettype</span><span class="params">(obj)</span> {</span>
  <span class="keyword">var</span> type = <span class="keyword">typeof</span> obj;

  <span class="keyword">if</span> (type !== <span class="string">'object'</span>) {
    <span class="keyword">return</span> type;
  }

  <span class="comment">// inspect [[Class]] for objects</span>
  <span class="keyword">return</span> toString.call(obj)
    .replace(objectRegExp, <span class="string">'$1'</span>);
}

<span class="comment">// merge params with parent params</span>
<span class="function"><span class="keyword">function</span> <span class="title">mergeParams</span><span class="params">(params, parent)</span> {</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> parent !== <span class="string">'object'</span> || !parent) {
    <span class="keyword">return</span> params;
  }

  <span class="comment">// make copy of parent for base</span>
  <span class="keyword">var</span> obj = mixin({}, parent);

  <span class="comment">// simple non-numeric merging</span>
  <span class="keyword">if</span> (!(<span class="number">0</span> <span class="keyword">in</span> params) || !(<span class="number">0</span> <span class="keyword">in</span> parent)) {
    <span class="keyword">return</span> mixin(obj, params);
  }

  <span class="keyword">var</span> i = <span class="number">0</span>;
  <span class="keyword">var</span> o = <span class="number">0</span>;

  <span class="comment">// determine numeric gaps</span>
  <span class="keyword">while</span> (i === o || o <span class="keyword">in</span> parent) {
    <span class="keyword">if</span> (i <span class="keyword">in</span> params) i++;
    <span class="keyword">if</span> (o <span class="keyword">in</span> parent) o++;
  }

  <span class="comment">// offset numeric indices in params before merge</span>
  <span class="keyword">for</span> (i--; i >= <span class="number">0</span>; i--) {
    params[i + o] = params[i];

    <span class="comment">// create holes for the merge when necessary</span>
    <span class="keyword">if</span> (i &lt; o) {
      <span class="keyword">delete</span> params[i];
    }
  }

  <span class="keyword">return</span> mixin(parent, params);
}

<span class="comment">// restore obj props after function</span>
<span class="function"><span class="keyword">function</span> <span class="title">restore</span><span class="params">(fn, obj)</span> {</span>
  <span class="keyword">var</span> props = <span class="keyword">new</span> Array(arguments.length - <span class="number">2</span>);
  <span class="keyword">var</span> vals = <span class="keyword">new</span> Array(arguments.length - <span class="number">2</span>);

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) {
    props[i] = arguments[i + <span class="number">2</span>];
    vals[i] = obj[props[i]];
  }

  <span class="keyword">return</span> <span class="keyword">function</span>(err){
    <span class="comment">// restore vals</span>
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) {
      obj[props[i]] = vals[i];
    }

    <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, arguments);
  };
}

<span class="comment">// wrap a function</span>
<span class="function"><span class="keyword">function</span> <span class="title">wrap</span><span class="params">(old, fn)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span><span class="params">()</span> {</span>
    <span class="keyword">var</span> args = <span class="keyword">new</span> Array(arguments.length + <span class="number">1</span>);

    args[<span class="number">0</span>] = old;
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arguments.length; i &lt; len; i++) {
      args[i + <span class="number">1</span>] = arguments[i];
    }

    fn.apply(<span class="keyword">this</span>, args);
  };
}
</code></pre>