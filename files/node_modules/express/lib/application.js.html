<h1>application.js</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Module dependencies.
 */</span>

<span class="keyword">var</span> finalhandler = require(<span class="string">'finalhandler'</span>);
<span class="keyword">var</span> flatten = require(<span class="string">'./utils'</span>).flatten;
<span class="keyword">var</span> mixin = require(<span class="string">'utils-merge'</span>);
<span class="keyword">var</span> Router = require(<span class="string">'./router'</span>);
<span class="keyword">var</span> methods = require(<span class="string">'methods'</span>);
<span class="keyword">var</span> middleware = require(<span class="string">'./middleware/init'</span>);
<span class="keyword">var</span> query = require(<span class="string">'./middleware/query'</span>);
<span class="keyword">var</span> debug = require(<span class="string">'debug'</span>)(<span class="string">'express:application'</span>);
<span class="keyword">var</span> View = require(<span class="string">'./view'</span>);
<span class="keyword">var</span> http = require(<span class="string">'http'</span>);
<span class="keyword">var</span> compileETag = require(<span class="string">'./utils'</span>).compileETag;
<span class="keyword">var</span> compileQueryParser = require(<span class="string">'./utils'</span>).compileQueryParser;
<span class="keyword">var</span> compileTrust = require(<span class="string">'./utils'</span>).compileTrust;
<span class="keyword">var</span> deprecate = require(<span class="string">'depd'</span>)(<span class="string">'express'</span>);
<span class="keyword">var</span> resolve = require(<span class="string">'path'</span>).resolve;
<span class="keyword">var</span> slice = Array.prototype.slice;

<span class="comment">/**
 * Application prototype.
 */</span>

<span class="keyword">var</span> app = exports = module.exports = {};

<span class="comment">/**
 * Initialize the server.
 *
 *   - setup default configuration
 *   - setup default middleware
 *   - setup route reflection methods
 *
 * @api private
 */</span>

app.init = <span class="keyword">function</span>(){
  <span class="keyword">this</span>.cache = {};
  <span class="keyword">this</span>.settings = {};
  <span class="keyword">this</span>.engines = {};
  <span class="keyword">this</span>.defaultConfiguration();
};

<span class="comment">/**
 * Initialize application configuration.
 *
 * @api private
 */</span>

app.defaultConfiguration = <span class="keyword">function</span>(){
  <span class="comment">// default settings</span>
  <span class="keyword">this</span>.enable(<span class="string">'x-powered-by'</span>);
  <span class="keyword">this</span>.set(<span class="string">'etag'</span>, <span class="string">'weak'</span>);
  <span class="keyword">var</span> env = process.env.NODE_ENV || <span class="string">'development'</span>;
  <span class="keyword">this</span>.set(<span class="string">'env'</span>, env);
  <span class="keyword">this</span>.set(<span class="string">'query parser'</span>, <span class="string">'extended'</span>);
  <span class="keyword">this</span>.set(<span class="string">'subdomain offset'</span>, <span class="number">2</span>);
  <span class="keyword">this</span>.set(<span class="string">'trust proxy'</span>, <span class="literal">false</span>);

  debug(<span class="string">'booting in %s mode'</span>, env);

  <span class="comment">// inherit protos</span>
  <span class="keyword">this</span>.on(<span class="string">'mount'</span>, <span class="keyword">function</span>(parent){
    <span class="keyword">this</span>.request.__proto__ = parent.request;
    <span class="keyword">this</span>.response.__proto__ = parent.response;
    <span class="keyword">this</span>.engines.__proto__ = parent.engines;
    <span class="keyword">this</span>.settings.__proto__ = parent.settings;
  });

  <span class="comment">// setup locals</span>
  <span class="keyword">this</span>.locals = Object.create(<span class="literal">null</span>);

  <span class="comment">// top-most app is mounted at /</span>
  <span class="keyword">this</span>.mountpath = <span class="string">'/'</span>;

  <span class="comment">// default locals</span>
  <span class="keyword">this</span>.locals.settings = <span class="keyword">this</span>.settings;

  <span class="comment">// default configuration</span>
  <span class="keyword">this</span>.set(<span class="string">'view'</span>, View);
  <span class="keyword">this</span>.set(<span class="string">'views'</span>, resolve(<span class="string">'views'</span>));
  <span class="keyword">this</span>.set(<span class="string">'jsonp callback name'</span>, <span class="string">'callback'</span>);

  <span class="keyword">if</span> (env === <span class="string">'production'</span>) {
    <span class="keyword">this</span>.enable(<span class="string">'view cache'</span>);
  }

  Object.defineProperty(<span class="keyword">this</span>, <span class="string">'router'</span>, {
    get: <span class="keyword">function</span>() {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'\'app.router\' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.'</span>);
    }
  });
};

<span class="comment">/**
 * lazily adds the base router if it has not yet been added.
 *
 * We cannot add the base router in the defaultConfiguration because
 * it reads app settings which might be set after that has run.
 *
 * @api private
 */</span>
app.lazyrouter = <span class="keyword">function</span>() {
  <span class="keyword">if</span> (!<span class="keyword">this</span>._router) {
    <span class="keyword">this</span>._router = <span class="keyword">new</span> Router({
      caseSensitive: <span class="keyword">this</span>.enabled(<span class="string">'case sensitive routing'</span>),
      strict: <span class="keyword">this</span>.enabled(<span class="string">'strict routing'</span>)
    });

    <span class="keyword">this</span>._router.use(query(<span class="keyword">this</span>.get(<span class="string">'query parser fn'</span>)));
    <span class="keyword">this</span>._router.use(middleware.init(<span class="keyword">this</span>));
  }
};

<span class="comment">/**
 * Dispatch a req, res pair into the application. Starts pipeline processing.
 *
 * If no _done_ callback is provided, then default error handlers will respond
 * in the event of an error bubbling through the stack.
 *
 * @api private
 */</span>

app.handle = <span class="keyword">function</span>(req, res, done) {
  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;

  <span class="comment">// final handler</span>
  done = done || finalhandler(req, res, {
    env: <span class="keyword">this</span>.get(<span class="string">'env'</span>),
    onerror: logerror.bind(<span class="keyword">this</span>)
  });

  <span class="comment">// no routes</span>
  <span class="keyword">if</span> (!router) {
    debug(<span class="string">'no routes defined on app'</span>);
    done();
    <span class="keyword">return</span>;
  }

  router.handle(req, res, done);
};

<span class="comment">/**
 * Proxy `Router#use()` to add middleware to the app router.
 * See Router#use() documentation for details.
 *
 * If the _fn_ parameter is an express app, then it will be
 * mounted at the _route_ specified.
 *
 * @api public
 */</span>

app.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span><span class="params">(fn)</span> {</span>
  <span class="keyword">var</span> offset = <span class="number">0</span>;
  <span class="keyword">var</span> path = <span class="string">'/'</span>;
  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="comment">// default path to '/'</span>
  <span class="comment">// disambiguate app.use([fn])</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>) {
    <span class="keyword">var</span> arg = fn;

    <span class="keyword">while</span> (Array.isArray(arg) &amp;&amp; arg.length !== <span class="number">0</span>) {
      arg = arg[<span class="number">0</span>];
    }

    <span class="comment">// first arg is the path</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> arg !== <span class="string">'function'</span>) {
      offset = <span class="number">1</span>;
      path = fn;
    }
  }

  <span class="keyword">var</span> fns = flatten(slice.call(arguments, offset));

  <span class="keyword">if</span> (fns.length === <span class="number">0</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'app.use() requires middleware functions'</span>);
  }

  <span class="comment">// setup router</span>
  <span class="keyword">this</span>.lazyrouter();
  <span class="keyword">var</span> router = <span class="keyword">this</span>._router;

  fns.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(fn)</span> {</span>
    <span class="comment">// non-express app</span>
    <span class="keyword">if</span> (!fn || !fn.handle || !fn.set) {
      <span class="keyword">return</span> router.use(path, fn);
    }

    debug(<span class="string">'.use app under %s'</span>, path);
    fn.mountpath = path;
    fn.parent = self;

    <span class="comment">// restore .app property on req and res</span>
    router.use(path, <span class="function"><span class="keyword">function</span> <span class="title">mounted_app</span><span class="params">(req, res, next)</span> {</span>
      <span class="keyword">var</span> orig = req.app;
      fn.handle(req, res, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
        req.__proto__ = orig.request;
        res.__proto__ = orig.response;
        next(err);
      });
    });

    <span class="comment">// mounted an app</span>
    fn.emit(<span class="string">'mount'</span>, self);
  });

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Proxy to the app `Router#route()`
 * Returns a new `Route` instance for the _path_.
 *
 * Routes are isolated middleware stacks for specific paths.
 * See the Route api docs for details.
 *
 * @api public
 */</span>

app.route = <span class="keyword">function</span>(path){
  <span class="keyword">this</span>.lazyrouter();
  <span class="keyword">return</span> <span class="keyword">this</span>._router.route(path);
};

<span class="comment">/**
 * Register the given template engine callback `fn`
 * as `ext`.
 *
 * By default will `require()` the engine based on the
 * file extension. For example if you try to render
 * a "foo.jade" file Express will invoke the following internally:
 *
 *     app.engine('jade', require('jade').__express);
 *
 * For engines that do not provide `.__express` out of the box,
 * or if you wish to "map" a different extension to the template engine
 * you may use this method. For example mapping the EJS template engine to
 * ".html" files:
 *
 *     app.engine('html', require('ejs').renderFile);
 *
 * In this case EJS provides a `.renderFile()` method with
 * the same signature that Express expects: `(path, options, callback)`,
 * though note that it aliases this method as `ejs.__express` internally
 * so if you're using ".ejs" extensions you dont need to do anything.
 *
 * Some template engines do not follow this convention, the
 * [Consolidate.js](https://github.com/visionmedia/consolidate.js)
 * library was created to map all of node's popular template
 * engines to follow this convention, thus allowing them to
 * work seamlessly within Express.
 *
 * @param {String} ext
 * @param {Function} fn
 * @return {app} for chaining
 * @api public
 */</span>

app.engine = <span class="keyword">function</span>(ext, fn){
  <span class="keyword">if</span> (<span class="string">'function'</span> != <span class="keyword">typeof</span> fn) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'callback function required'</span>);
  <span class="keyword">if</span> (<span class="string">'.'</span> != ext[<span class="number">0</span>]) ext = <span class="string">'.'</span> + ext;
  <span class="keyword">this</span>.engines[ext] = fn;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Proxy to `Router#param()` with one added api feature. The _name_ parameter
 * can be an array of names.
 *
 * See the Router#param() docs for more details.
 *
 * @param {String|Array} name
 * @param {Function} fn
 * @return {app} for chaining
 * @api public
 */</span>

app.param = <span class="keyword">function</span>(name, fn){
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  self.lazyrouter();

  <span class="keyword">if</span> (Array.isArray(name)) {
    name.forEach(<span class="keyword">function</span>(key) {
      self.param(key, fn);
    });
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  self._router.param(name, fn);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Assign `setting` to `val`, or return `setting`'s value.
 *
 *    app.set('foo', 'bar');
 *    app.get('foo');
 *    // => "bar"
 *
 * Mounted servers inherit their parent server's settings.
 *
 * @param {String} setting
 * @param {*} [val]
 * @return {Server} for chaining
 * @api public
 */</span>

app.set = <span class="keyword">function</span>(setting, val){
  <span class="keyword">if</span> (arguments.length === <span class="number">1</span>) {
    <span class="comment">// app.get(setting)</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.settings[setting];
  }

  <span class="comment">// set value</span>
  <span class="keyword">this</span>.settings[setting] = val;

  <span class="comment">// trigger matched settings</span>
  <span class="keyword">switch</span> (setting) {
    <span class="keyword">case</span> <span class="string">'etag'</span>:
      debug(<span class="string">'compile etag %s'</span>, val);
      <span class="keyword">this</span>.set(<span class="string">'etag fn'</span>, compileETag(val));
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'query parser'</span>:
      debug(<span class="string">'compile query parser %s'</span>, val);
      <span class="keyword">this</span>.set(<span class="string">'query parser fn'</span>, compileQueryParser(val));
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'trust proxy'</span>:
      debug(<span class="string">'compile trust proxy %s'</span>, val);
      <span class="keyword">this</span>.set(<span class="string">'trust proxy fn'</span>, compileTrust(val));
      <span class="keyword">break</span>;
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Return the app's absolute pathname
 * based on the parent(s) that have
 * mounted it.
 *
 * For example if the application was
 * mounted as "/admin", which itself
 * was mounted as "/blog" then the
 * return value would be "/blog/admin".
 *
 * @return {String}
 * @api private
 */</span>

app.path = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="keyword">this</span>.parent
    ? <span class="keyword">this</span>.parent.path() + <span class="keyword">this</span>.mountpath
    : <span class="string">''</span>;
};

<span class="comment">/**
 * Check if `setting` is enabled (truthy).
 *
 *    app.enabled('foo')
 *    // => false
 *
 *    app.enable('foo')
 *    app.enabled('foo')
 *    // => true
 *
 * @param {String} setting
 * @return {Boolean}
 * @api public
 */</span>

app.enabled = <span class="keyword">function</span>(setting){
  <span class="keyword">return</span> !!<span class="keyword">this</span>.set(setting);
};

<span class="comment">/**
 * Check if `setting` is disabled.
 *
 *    app.disabled('foo')
 *    // => true
 *
 *    app.enable('foo')
 *    app.disabled('foo')
 *    // => false
 *
 * @param {String} setting
 * @return {Boolean}
 * @api public
 */</span>

app.disabled = <span class="keyword">function</span>(setting){
  <span class="keyword">return</span> !<span class="keyword">this</span>.set(setting);
};

<span class="comment">/**
 * Enable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @api public
 */</span>

app.enable = <span class="keyword">function</span>(setting){
  <span class="keyword">return</span> <span class="keyword">this</span>.set(setting, <span class="literal">true</span>);
};

<span class="comment">/**
 * Disable `setting`.
 *
 * @param {String} setting
 * @return {app} for chaining
 * @api public
 */</span>

app.disable = <span class="keyword">function</span>(setting){
  <span class="keyword">return</span> <span class="keyword">this</span>.set(setting, <span class="literal">false</span>);
};

<span class="comment">/**
 * Delegate `.VERB(...)` calls to `router.VERB(...)`.
 */</span>

methods.forEach(<span class="keyword">function</span>(method){
  app[method] = <span class="keyword">function</span>(path){
    <span class="keyword">if</span> (<span class="string">'get'</span> == method &amp;&amp; <span class="number">1</span> == arguments.length) <span class="keyword">return</span> <span class="keyword">this</span>.set(path);

    <span class="keyword">this</span>.lazyrouter();

    <span class="keyword">var</span> route = <span class="keyword">this</span>._router.route(path);
    route[method].apply(route, slice.call(arguments, <span class="number">1</span>));
    <span class="keyword">return</span> <span class="keyword">this</span>;
  };
});

<span class="comment">/**
 * Special-cased "all" method, applying the given route `path`,
 * middleware, and callback to _every_ HTTP method.
 *
 * @param {String} path
 * @param {Function} ...
 * @return {app} for chaining
 * @api public
 */</span>

app.all = <span class="keyword">function</span>(path){
  <span class="keyword">this</span>.lazyrouter();

  <span class="keyword">var</span> route = <span class="keyword">this</span>._router.route(path);
  <span class="keyword">var</span> args = slice.call(arguments, <span class="number">1</span>);
  methods.forEach(<span class="keyword">function</span>(method){
    route[method].apply(route, args);
  });

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">// del -> delete alias</span>

app.del = deprecate.<span class="keyword">function</span>(app.<span class="keyword">delete</span>, <span class="string">'app.del: Use app.delete instead'</span>);

<span class="comment">/**
 * Render the given view `name` name with `options`
 * and a callback accepting an error and the
 * rendered template string.
 *
 * Example:
 *
 *    app.render('email', { name: 'Tobi' }, function(err, html){
 *      // ...
 *    })
 *
 * @param {String} name
 * @param {String|Function} options or fn
 * @param {Function} fn
 * @api public
 */</span>

app.render = <span class="keyword">function</span>(name, options, fn){
  <span class="keyword">var</span> opts = {};
  <span class="keyword">var</span> cache = <span class="keyword">this</span>.cache;
  <span class="keyword">var</span> engines = <span class="keyword">this</span>.engines;
  <span class="keyword">var</span> view;

  <span class="comment">// support callback function as second arg</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> options) {
    fn = options, options = {};
  }

  <span class="comment">// merge app.locals</span>
  mixin(opts, <span class="keyword">this</span>.locals);

  <span class="comment">// merge options._locals</span>
  <span class="keyword">if</span> (options._locals) mixin(opts, options._locals);

  <span class="comment">// merge options</span>
  mixin(opts, options);

  <span class="comment">// set .cache unless explicitly provided</span>
  opts.cache = <span class="literal">null</span> == opts.cache
    ? <span class="keyword">this</span>.enabled(<span class="string">'view cache'</span>)
    : opts.cache;

  <span class="comment">// primed cache</span>
  <span class="keyword">if</span> (opts.cache) view = cache[name];

  <span class="comment">// view</span>
  <span class="keyword">if</span> (!view) {
    view = <span class="keyword">new</span> (<span class="keyword">this</span>.get(<span class="string">'view'</span>))(name, {
      defaultEngine: <span class="keyword">this</span>.get(<span class="string">'view engine'</span>),
      root: <span class="keyword">this</span>.get(<span class="string">'views'</span>),
      engines: engines
    });

    <span class="keyword">if</span> (!view.path) {
      <span class="keyword">var</span> err = <span class="keyword">new</span> Error(<span class="string">'Failed to lookup view "'</span> + name + <span class="string">'" in views directory "'</span> + view.root + <span class="string">'"'</span>);
      err.view = view;
      <span class="keyword">return</span> fn(err);
    }

    <span class="comment">// prime the cache</span>
    <span class="keyword">if</span> (opts.cache) cache[name] = view;
  }

  <span class="comment">// render</span>
  <span class="keyword">try</span> {
    view.render(opts, fn);
  } <span class="keyword">catch</span> (err) {
    fn(err);
  }
};

<span class="comment">/**
 * Listen for connections.
 *
 * A node `http.Server` is returned, with this
 * application (which is a `Function`) as its
 * callback. If you wish to create both an HTTP
 * and HTTPS server you may do so with the "http"
 * and "https" modules as shown here:
 *
 *    var http = require('http')
 *      , https = require('https')
 *      , express = require('express')
 *      , app = express();
 *
 *    http.createServer(app).listen(80);
 *    https.createServer({ ... }, app).listen(443);
 *
 * @return {http.Server}
 * @api public
 */</span>

app.listen = <span class="keyword">function</span>(){
  <span class="keyword">var</span> server = http.createServer(<span class="keyword">this</span>);
  <span class="keyword">return</span> server.listen.apply(server, arguments);
};

<span class="comment">/**
* Log error using console.error.
*
* @param {Error} err
* @api public
*/</span>

<span class="function"><span class="keyword">function</span> <span class="title">logerror</span><span class="params">(err)</span>{</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.get(<span class="string">'env'</span>) !== <span class="string">'test'</span>) console.error(err.stack || err.toString());
}
</code></pre>