<h1>response.js</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Module dependencies.
 */</span>

<span class="keyword">var</span> deprecate = require(<span class="string">'depd'</span>)(<span class="string">'express'</span>);
<span class="keyword">var</span> escapeHtml = require(<span class="string">'escape-html'</span>);
<span class="keyword">var</span> http = require(<span class="string">'http'</span>);
<span class="keyword">var</span> isAbsolute = require(<span class="string">'./utils'</span>).isAbsolute;
<span class="keyword">var</span> onFinished = require(<span class="string">'on-finished'</span>);
<span class="keyword">var</span> path = require(<span class="string">'path'</span>);
<span class="keyword">var</span> mixin = require(<span class="string">'utils-merge'</span>);
<span class="keyword">var</span> sign = require(<span class="string">'cookie-signature'</span>).sign;
<span class="keyword">var</span> normalizeType = require(<span class="string">'./utils'</span>).normalizeType;
<span class="keyword">var</span> normalizeTypes = require(<span class="string">'./utils'</span>).normalizeTypes;
<span class="keyword">var</span> setCharset = require(<span class="string">'./utils'</span>).setCharset;
<span class="keyword">var</span> contentDisposition = require(<span class="string">'./utils'</span>).contentDisposition;
<span class="keyword">var</span> statusCodes = http.STATUS_CODES;
<span class="keyword">var</span> cookie = require(<span class="string">'cookie'</span>);
<span class="keyword">var</span> send = require(<span class="string">'send'</span>);
<span class="keyword">var</span> extname = path.extname;
<span class="keyword">var</span> mime = send.mime;
<span class="keyword">var</span> resolve = path.resolve;
<span class="keyword">var</span> vary = require(<span class="string">'vary'</span>);

<span class="comment">/**
 * Response prototype.
 */</span>

<span class="keyword">var</span> res = module.exports = {
  __proto__: http.ServerResponse.prototype
};

<span class="comment">/**
 * Set status `code`.
 *
 * @param {Number} code
 * @return {ServerResponse}
 * @api public
 */</span>

res.status = <span class="keyword">function</span>(code){
  <span class="keyword">this</span>.statusCode = code;
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: 'http://api.example.com/users?page=2',
 *      last: 'http://api.example.com/users?page=5'
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @api public
 */</span>

res.links = <span class="keyword">function</span>(links){
  <span class="keyword">var</span> link = <span class="keyword">this</span>.get(<span class="string">'Link'</span>) || <span class="string">''</span>;
  <span class="keyword">if</span> (link) link += <span class="string">', '</span>;
  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="string">'Link'</span>, link + Object.keys(links).map(<span class="keyword">function</span>(rel){
    <span class="keyword">return</span> <span class="string">'&lt;'</span> + links[rel] + <span class="string">'>; rel="'</span> + rel + <span class="string">'"'</span>;
  }).join(<span class="string">', '</span>));
};

<span class="comment">/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(new Buffer('wahoo'));
 *     res.send({ some: 'json' });
 *     res.send('&lt;p>some html&lt;/p>');
 *
 * @param {string|number|boolean|object|Buffer} body
 * @api public
 */</span>

res.send = <span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(body)</span> {</span>
  <span class="keyword">var</span> chunk = body;
  <span class="keyword">var</span> encoding;
  <span class="keyword">var</span> len;
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;
  <span class="keyword">var</span> type;

  <span class="comment">// settings</span>
  <span class="keyword">var</span> app = <span class="keyword">this</span>.app;

  <span class="comment">// allow status / body</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
    <span class="comment">// res.send(body, status) backwards compat</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] !== <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> arguments[<span class="number">1</span>] === <span class="string">'number'</span>) {
      deprecate(<span class="string">'res.send(body, status): Use res.status(status).send(body) instead'</span>);
      <span class="keyword">this</span>.statusCode = arguments[<span class="number">1</span>];
    } <span class="keyword">else</span> {
      deprecate(<span class="string">'res.send(status, body): Use res.status(status).send(body) instead'</span>);
      <span class="keyword">this</span>.statusCode = arguments[<span class="number">0</span>];
      chunk = arguments[<span class="number">1</span>];
    }
  }

  <span class="comment">// disambiguate res.send(status) and res.send(status, num)</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk === <span class="string">'number'</span> &amp;&amp; arguments.length === <span class="number">1</span>) {
    <span class="comment">// res.send(status) will set status message as text string</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.get(<span class="string">'Content-Type'</span>)) {
      <span class="keyword">this</span>.type(<span class="string">'txt'</span>);
    }

    deprecate(<span class="string">'res.send(status): Use res.status(status).end() instead'</span>);
    <span class="keyword">this</span>.statusCode = chunk;
    chunk = http.STATUS_CODES[chunk];
  }

  <span class="keyword">switch</span> (<span class="keyword">typeof</span> chunk) {
    <span class="comment">// string defaulting to html</span>
    <span class="keyword">case</span> <span class="string">'string'</span>:
      <span class="keyword">if</span> (!<span class="keyword">this</span>.get(<span class="string">'Content-Type'</span>)) {
        <span class="keyword">this</span>.type(<span class="string">'html'</span>);
      }
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'boolean'</span>:
    <span class="keyword">case</span> <span class="string">'number'</span>:
    <span class="keyword">case</span> <span class="string">'object'</span>:
      <span class="keyword">if</span> (chunk === <span class="literal">null</span>) {
        chunk = <span class="string">''</span>;
      } <span class="keyword">else</span> <span class="keyword">if</span> (Buffer.isBuffer(chunk)) {
        <span class="keyword">if</span> (!<span class="keyword">this</span>.get(<span class="string">'Content-Type'</span>)) {
          <span class="keyword">this</span>.type(<span class="string">'bin'</span>);
        }
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> <span class="keyword">this</span>.json(chunk);
      }
      <span class="keyword">break</span>;
  }

  <span class="comment">// write strings in utf-8</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> chunk === <span class="string">'string'</span>) {
    encoding = <span class="string">'utf8'</span>;
    type = <span class="keyword">this</span>.get(<span class="string">'Content-Type'</span>);

    <span class="comment">// reflect this in content-type</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> type === <span class="string">'string'</span>) {
      <span class="keyword">this</span>.set(<span class="string">'Content-Type'</span>, setCharset(type, <span class="string">'utf-8'</span>));
    }
  }

  <span class="comment">// populate Content-Length</span>
  <span class="keyword">if</span> (chunk !== <span class="literal">undefined</span>) {
    <span class="keyword">if</span> (!Buffer.isBuffer(chunk)) {
      <span class="comment">// convert chunk to Buffer; saves later double conversions</span>
      chunk = <span class="keyword">new</span> Buffer(chunk, encoding);
      encoding = <span class="literal">undefined</span>;
    }

    len = chunk.length;
    <span class="keyword">this</span>.set(<span class="string">'Content-Length'</span>, len);
  }

  <span class="comment">// method check</span>
  <span class="keyword">var</span> isHead = req.method === <span class="string">'HEAD'</span>;

  <span class="comment">// ETag support</span>
  <span class="keyword">if</span> (len !== <span class="literal">undefined</span> &amp;&amp; (isHead || req.method === <span class="string">'GET'</span>)) {
    <span class="keyword">var</span> etag = app.get(<span class="string">'etag fn'</span>);
    <span class="keyword">if</span> (etag &amp;&amp; !<span class="keyword">this</span>.get(<span class="string">'ETag'</span>)) {
      etag = etag(chunk, encoding);
      etag &amp;&amp; <span class="keyword">this</span>.set(<span class="string">'ETag'</span>, etag);
    }
  }

  <span class="comment">// freshness</span>
  <span class="keyword">if</span> (req.fresh) <span class="keyword">this</span>.statusCode = <span class="number">304</span>;

  <span class="comment">// strip irrelevant headers</span>
  <span class="keyword">if</span> (<span class="number">204</span> == <span class="keyword">this</span>.statusCode || <span class="number">304</span> == <span class="keyword">this</span>.statusCode) {
    <span class="keyword">this</span>.removeHeader(<span class="string">'Content-Type'</span>);
    <span class="keyword">this</span>.removeHeader(<span class="string">'Content-Length'</span>);
    <span class="keyword">this</span>.removeHeader(<span class="string">'Transfer-Encoding'</span>);
    chunk = <span class="string">''</span>;
  }

  <span class="comment">// skip body for HEAD</span>
  <span class="keyword">if</span> (isHead) {
    <span class="keyword">this</span>.end();
  }

  <span class="comment">// respond</span>
  <span class="keyword">this</span>.end(chunk, encoding);

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @api public
 */</span>

res.json = <span class="function"><span class="keyword">function</span> <span class="title">json</span><span class="params">(obj)</span> {</span>
  <span class="keyword">var</span> val = obj;

  <span class="comment">// allow status / body</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
    <span class="comment">// res.json(body, status) backwards compat</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">1</span>] === <span class="string">'number'</span>) {
      deprecate(<span class="string">'res.json(obj, status): Use res.status(status).json(obj) instead'</span>);
      <span class="keyword">this</span>.statusCode = arguments[<span class="number">1</span>];
    } <span class="keyword">else</span> {
      deprecate(<span class="string">'res.json(status, obj): Use res.status(status).json(obj) instead'</span>);
      <span class="keyword">this</span>.statusCode = arguments[<span class="number">0</span>];
      val = arguments[<span class="number">1</span>];
    }
  }

  <span class="comment">// settings</span>
  <span class="keyword">var</span> app = <span class="keyword">this</span>.app;
  <span class="keyword">var</span> replacer = app.get(<span class="string">'json replacer'</span>);
  <span class="keyword">var</span> spaces = app.get(<span class="string">'json spaces'</span>);
  <span class="keyword">var</span> body = JSON.stringify(val, replacer, spaces);

  <span class="comment">// content-type</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.get(<span class="string">'Content-Type'</span>)) {
    <span class="keyword">this</span>.set(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>.send(body);
};

<span class="comment">/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: 'tj' });
 *
 * @param {string|number|boolean|object} obj
 * @api public
 */</span>

res.jsonp = <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span><span class="params">(obj)</span> {</span>
  <span class="keyword">var</span> val = obj;

  <span class="comment">// allow status / body</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
    <span class="comment">// res.json(body, status) backwards compat</span>
    <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">1</span>] === <span class="string">'number'</span>) {
      deprecate(<span class="string">'res.jsonp(obj, status): Use res.status(status).json(obj) instead'</span>);
      <span class="keyword">this</span>.statusCode = arguments[<span class="number">1</span>];
    } <span class="keyword">else</span> {
      deprecate(<span class="string">'res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead'</span>);
      <span class="keyword">this</span>.statusCode = arguments[<span class="number">0</span>];
      val = arguments[<span class="number">1</span>];
    }
  }

  <span class="comment">// settings</span>
  <span class="keyword">var</span> app = <span class="keyword">this</span>.app;
  <span class="keyword">var</span> replacer = app.get(<span class="string">'json replacer'</span>);
  <span class="keyword">var</span> spaces = app.get(<span class="string">'json spaces'</span>);
  <span class="keyword">var</span> body = JSON.stringify(val, replacer, spaces);
  <span class="keyword">var</span> callback = <span class="keyword">this</span>.req.query[app.get(<span class="string">'jsonp callback name'</span>)];

  <span class="comment">// content-type</span>
  <span class="keyword">if</span> (!<span class="keyword">this</span>.get(<span class="string">'Content-Type'</span>)) {
    <span class="keyword">this</span>.set(<span class="string">'X-Content-Type-Options'</span>, <span class="string">'nosniff'</span>);
    <span class="keyword">this</span>.set(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);
  }

  <span class="comment">// fixup callback</span>
  <span class="keyword">if</span> (Array.isArray(callback)) {
    callback = callback[<span class="number">0</span>];
  }

  <span class="comment">// jsonp</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'string'</span> &amp;&amp; callback.length !== <span class="number">0</span>) {
    <span class="keyword">this</span>.charset = <span class="string">'utf-8'</span>;
    <span class="keyword">this</span>.set(<span class="string">'X-Content-Type-Options'</span>, <span class="string">'nosniff'</span>);
    <span class="keyword">this</span>.set(<span class="string">'Content-Type'</span>, <span class="string">'text/javascript'</span>);

    <span class="comment">// restrict callback charset</span>
    callback = callback.replace(<span class="regexp">/[^\[\]\w$.]/g</span>, <span class="string">''</span>);

    <span class="comment">// replace chars not allowed in JavaScript that are in JSON</span>
    body = body
      .replace(<span class="regexp">/\u2028/g</span>, <span class="string">'\\u2028'</span>)
      .replace(<span class="regexp">/\u2029/g</span>, <span class="string">'\\u2029'</span>);

    <span class="comment">// the /**/ is a specific security mitigation for "Rosetta Flash JSONP abuse"</span>
    <span class="comment">// the typeof check is just to reduce client error noise</span>
    body = <span class="string">'/**/ typeof '</span> + callback + <span class="string">' === \'function\' &amp;&amp; '</span> + callback + <span class="string">'('</span> + body + <span class="string">');'</span>;
  }

  <span class="keyword">return</span> <span class="keyword">this</span>.send(body);
};

<span class="comment">/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node's http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @api public
 */</span>

res.sendStatus = <span class="function"><span class="keyword">function</span> <span class="title">sendStatus</span><span class="params">(statusCode)</span> {</span>
  <span class="keyword">var</span> body = http.STATUS_CODES[statusCode] || String(statusCode);

  <span class="keyword">this</span>.statusCode = statusCode;
  <span class="keyword">this</span>.type(<span class="string">'txt'</span>);

  <span class="keyword">return</span> <span class="keyword">this</span>.send(body);
};

<span class="comment">/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `fn(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @api public
 */</span>

res.sendFile = <span class="function"><span class="keyword">function</span> <span class="title">sendFile</span><span class="params">(path, options, fn)</span> {</span>
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;
  <span class="keyword">var</span> res = <span class="keyword">this</span>;
  <span class="keyword">var</span> next = req.next;

  <span class="keyword">if</span> (!path) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'path argument is required to res.sendFile'</span>);
  }

  <span class="comment">// support function as second arg</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) {
    fn = options;
    options = {};
  }

  options = options || {};

  <span class="keyword">if</span> (!options.root &amp;&amp; !isAbsolute(path)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'path must be absolute or specify root to res.sendFile'</span>);
  }

  <span class="comment">// create file stream</span>
  <span class="keyword">var</span> pathname = encodeURI(path);
  <span class="keyword">var</span> file = send(req, pathname, options);

  <span class="comment">// transfer</span>
  sendfile(res, file, options, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (fn) <span class="keyword">return</span> fn(err);
    <span class="keyword">if</span> (err &amp;&amp; err.code === <span class="string">'EISDIR'</span>) <span class="keyword">return</span> next();

    <span class="comment">// next() all but aborted errors</span>
    <span class="keyword">if</span> (err &amp;&amp; err.code !== <span class="string">'ECONNABORT'</span>) {
      next(err);
    }
  });
};

<span class="comment">/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `fn(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.sentHeader`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendfile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendfile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get('/user/:uid/photos/:file', function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendfile('/uploads/' + uid + '/' + file);
 *         } else {
 *           res.send(403, 'Sorry! you cant see that.');
 *         }
 *       });
 *     });
 *
 * @api public
 */</span>

res.sendfile = <span class="keyword">function</span>(path, options, fn){
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;
  <span class="keyword">var</span> res = <span class="keyword">this</span>;
  <span class="keyword">var</span> next = req.next;

  <span class="comment">// support function as second arg</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> options === <span class="string">'function'</span>) {
    fn = options;
    options = {};
  }

  options = options || {};

  <span class="comment">// create file stream</span>
  <span class="keyword">var</span> file = send(req, path, options);

  <span class="comment">// transfer</span>
  sendfile(res, file, options, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (fn) <span class="keyword">return</span> fn(err);
    <span class="keyword">if</span> (err &amp;&amp; err.code === <span class="string">'EISDIR'</span>) <span class="keyword">return</span> next();

    <span class="comment">// next() all but aborted errors</span>
    <span class="keyword">if</span> (err &amp;&amp; err.code !== <span class="string">'ECONNABORT'</span>) {
      next(err);
    }
  });
};

res.sendfile = deprecate.<span class="keyword">function</span>(res.sendfile,
  <span class="string">'res.sendfile: Use res.sendFile instead'</span>);

<span class="comment">/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `fn(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * ocurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * This method uses `res.sendfile()`.
 *
 * @api public
 */</span>

res.download = <span class="function"><span class="keyword">function</span> <span class="title">download</span><span class="params">(path, filename, fn)</span> {</span>
  <span class="comment">// support function as second arg</span>
  <span class="keyword">if</span> (<span class="keyword">typeof</span> filename === <span class="string">'function'</span>) {
    fn = filename;
    filename = <span class="literal">null</span>;
  }

  filename = filename || path;

  <span class="comment">// set Content-Disposition when file is sent</span>
  <span class="keyword">var</span> headers = {
    <span class="string">'Content-Disposition'</span>: contentDisposition(filename)
  };

  <span class="comment">// Resolve the full path for sendFile</span>
  <span class="keyword">var</span> fullPath = resolve(path);

  <span class="keyword">return</span> <span class="keyword">this</span>.sendFile(fullPath, { headers: headers }, fn);
};

<span class="comment">/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain "/", or set the Content-Type to `type` otherwise.
 *
 * Examples:
 *
 *     res.type('.html');
 *     res.type('html');
 *     res.type('json');
 *     res.type('application/json');
 *     res.type('png');
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @api public
 */</span>

res.contentType =
res.type = <span class="keyword">function</span>(type){
  <span class="keyword">return</span> <span class="keyword">this</span>.set(<span class="string">'Content-Type'</span>, ~type.indexOf(<span class="string">'/'</span>)
    ? type
    : mime.lookup(type));
};

<span class="comment">/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When "Accept" is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 "Not Acceptable".
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set('Content-Type', ...)`.
 *
 *    res.format({
 *      'text/plain': function(){
 *        res.send('hey');
 *      },
 *
 *      'text/html': function(){
 *        res.send('&lt;p>hey&lt;/p>');
 *      },
 *
 *      'appliation/json': function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send('hey');
 *      },
 *
 *      html: function(){
 *        res.send('&lt;p>hey&lt;/p>');
 *      },
 *
 *      json: function(){
 *        res.send({ message: 'hey' });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @api public
 */</span>

res.format = <span class="keyword">function</span>(obj){
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;
  <span class="keyword">var</span> next = req.next;

  <span class="keyword">var</span> fn = obj.<span class="keyword">default</span>;
  <span class="keyword">if</span> (fn) <span class="keyword">delete</span> obj.<span class="keyword">default</span>;
  <span class="keyword">var</span> keys = Object.keys(obj);

  <span class="keyword">var</span> key = req.accepts(keys);

  <span class="keyword">this</span>.vary(<span class="string">"Accept"</span>);

  <span class="keyword">if</span> (key) {
    <span class="keyword">this</span>.set(<span class="string">'Content-Type'</span>, normalizeType(key).value);
    obj[key](req, <span class="keyword">this</span>, next);
  } <span class="keyword">else</span> <span class="keyword">if</span> (fn) {
    fn();
  } <span class="keyword">else</span> {
    <span class="keyword">var</span> err = <span class="keyword">new</span> Error(<span class="string">'Not Acceptable'</span>);
    err.status = <span class="number">406</span>;
    err.types = normalizeTypes(keys).map(<span class="keyword">function</span>(o){ <span class="keyword">return</span> o.value });
    next(err);
  }

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @api public
 */</span>

res.attachment = <span class="keyword">function</span>(filename){
  <span class="keyword">if</span> (filename) <span class="keyword">this</span>.type(extname(filename));
  <span class="keyword">this</span>.set(<span class="string">'Content-Disposition'</span>, contentDisposition(filename));
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set('Foo', ['bar', 'baz']);
 *    res.set('Accept', 'application/json');
 *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
 *
 * Aliased as `res.header()`.
 *
 * @param {String|Object|Array} field
 * @param {String} val
 * @return {ServerResponse} for chaining
 * @api public
 */</span>

res.set =
res.header = <span class="function"><span class="keyword">function</span> <span class="title">header</span><span class="params">(field, val)</span> {</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
    <span class="keyword">if</span> (Array.isArray(val)) val = val.map(String);
    <span class="keyword">else</span> val = String(val);
    <span class="keyword">if</span> (<span class="string">'content-type'</span> == field.toLowerCase() &amp;&amp; !<span class="regexp">/;\s*charset\s*=/</span>.test(val)) {
      <span class="keyword">var</span> charset = mime.charsets.lookup(val.split(<span class="string">';'</span>)[<span class="number">0</span>]);
      <span class="keyword">if</span> (charset) val += <span class="string">'; charset='</span> + charset.toLowerCase();
    }
    <span class="keyword">this</span>.setHeader(field, val);
  } <span class="keyword">else</span> {
    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> field) {
      <span class="keyword">this</span>.set(key, field[key]);
    }
  }
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */</span>

res.get = <span class="keyword">function</span>(field){
  <span class="keyword">return</span> <span class="keyword">this</span>.getHeader(field);
};

<span class="comment">/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} options
 * @return {ServerResponse} for chaining
 * @api public
 */</span>

res.clearCookie = <span class="keyword">function</span>(name, options){
  <span class="keyword">var</span> opts = { expires: <span class="keyword">new</span> Date(<span class="number">1</span>), path: <span class="string">'/'</span> };
  <span class="keyword">return</span> <span class="keyword">this</span>.cookie(name, <span class="string">''</span>, options
    ? mixin(opts, options)
    : opts);
};

<span class="comment">/**
 * Set cookie `name` to `val`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to "/"
 *
 * Examples:
 *
 *    // "Remember Me" for 15 minutes
 *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // save as above
 *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} val
 * @param {Options} options
 * @return {ServerResponse} for chaining
 * @api public
 */</span>

res.cookie = <span class="keyword">function</span>(name, val, options){
  options = mixin({}, options);
  <span class="keyword">var</span> secret = <span class="keyword">this</span>.req.secret;
  <span class="keyword">var</span> signed = options.signed;
  <span class="keyword">if</span> (signed &amp;&amp; !secret) <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'cookieParser("secret") required for signed cookies'</span>);
  <span class="keyword">if</span> (<span class="string">'number'</span> == <span class="keyword">typeof</span> val) val = val.toString();
  <span class="keyword">if</span> (<span class="string">'object'</span> == <span class="keyword">typeof</span> val) val = <span class="string">'j:'</span> + JSON.stringify(val);
  <span class="keyword">if</span> (signed) val = <span class="string">'s:'</span> + sign(val, secret);
  <span class="keyword">if</span> (<span class="string">'maxAge'</span> <span class="keyword">in</span> options) {
    options.expires = <span class="keyword">new</span> Date(Date.now() + options.maxAge);
    options.maxAge /= <span class="number">1000</span>;
  }
  <span class="keyword">if</span> (<span class="literal">null</span> == options.path) options.path = <span class="string">'/'</span>;
  <span class="keyword">var</span> headerVal = cookie.serialize(name, String(val), options);

  <span class="comment">// supports multiple 'res.cookie' calls by getting previous value</span>
  <span class="keyword">var</span> prev = <span class="keyword">this</span>.get(<span class="string">'Set-Cookie'</span>);
  <span class="keyword">if</span> (prev) {
    <span class="keyword">if</span> (Array.isArray(prev)) {
      headerVal = prev.concat(headerVal);
    } <span class="keyword">else</span> {
      headerVal = [prev, headerVal];
    }
  }
  <span class="keyword">this</span>.set(<span class="string">'Set-Cookie'</span>, headerVal);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};


<span class="comment">/**
 * Set the location header to `url`.
 *
 * The given `url` can also be "back", which redirects
 * to the _Referrer_ or _Referer_ headers or "/".
 *
 * Examples:
 *
 *    res.location('/foo/bar').;
 *    res.location('http://example.com');
 *    res.location('../login');
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @api public
 */</span>

res.location = <span class="keyword">function</span>(url){
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;

  <span class="comment">// "back" is an alias for the referrer</span>
  <span class="keyword">if</span> (<span class="string">'back'</span> == url) url = req.get(<span class="string">'Referrer'</span>) || <span class="string">'/'</span>;

  <span class="comment">// Respond</span>
  <span class="keyword">this</span>.set(<span class="string">'Location'</span>, url);
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * The resulting `url` is determined by `res.location()`, so
 * it will play nicely with mounted apps, relative paths,
 * `"back"` etc.
 *
 * Examples:
 *
 *    res.redirect('/foo/bar');
 *    res.redirect('http://example.com');
 *    res.redirect(301, 'http://example.com');
 *    res.redirect('../login'); // /blog/post/1 -> /blog/login
 *
 * @api public
 */</span>

res.redirect = <span class="function"><span class="keyword">function</span> <span class="title">redirect</span><span class="params">(url)</span> {</span>
  <span class="keyword">var</span> address = url;
  <span class="keyword">var</span> body;
  <span class="keyword">var</span> status = <span class="number">302</span>;

  <span class="comment">// allow status / url</span>
  <span class="keyword">if</span> (arguments.length === <span class="number">2</span>) {
    <span class="keyword">if</span> (<span class="keyword">typeof</span> arguments[<span class="number">0</span>] === <span class="string">'number'</span>) {
      status = arguments[<span class="number">0</span>];
      address = arguments[<span class="number">1</span>];
    } <span class="keyword">else</span> {
      deprecate(<span class="string">'res.redirect(url, status): Use res.redirect(status, url) instead'</span>);
      status = arguments[<span class="number">1</span>];
    }
  }

  <span class="comment">// Set location header</span>
  <span class="keyword">this</span>.location(address);
  address = <span class="keyword">this</span>.get(<span class="string">'Location'</span>);

  <span class="comment">// Support text/{plain,html} by default</span>
  <span class="keyword">this</span>.format({
    text: <span class="keyword">function</span>(){
      body = statusCodes[status] + <span class="string">'. Redirecting to '</span> + encodeURI(address);
    },

    html: <span class="keyword">function</span>(){
      <span class="keyword">var</span> u = escapeHtml(address);
      body = <span class="string">'&lt;p>'</span> + statusCodes[status] + <span class="string">'. Redirecting to &lt;a href="'</span> + u + <span class="string">'">'</span> + u + <span class="string">'&lt;/a>&lt;/p>'</span>;
    },

    <span class="keyword">default</span>: <span class="keyword">function</span>(){
      body = <span class="string">''</span>;
    }
  });

  <span class="comment">// Respond</span>
  <span class="keyword">this</span>.statusCode = status;
  <span class="keyword">this</span>.set(<span class="string">'Content-Length'</span>, Buffer.byteLength(body));

  <span class="keyword">if</span> (<span class="keyword">this</span>.req.method === <span class="string">'HEAD'</span>) {
    <span class="keyword">this</span>.end();
  }

  <span class="keyword">this</span>.end(body);
};

<span class="comment">/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @api public
 */</span>

res.vary = <span class="keyword">function</span>(field){
  <span class="comment">// checks for back-compat</span>
  <span class="keyword">if</span> (!field || (Array.isArray(field) &amp;&amp; !field.length)) {
    deprecate(<span class="string">'res.vary(): Provide a field name'</span>);
    <span class="keyword">return</span> <span class="keyword">this</span>;
  }

  vary(<span class="keyword">this</span>, field);

  <span class="keyword">return</span> <span class="keyword">this</span>;
};

<span class="comment">/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @api public
 */</span>

res.render = <span class="keyword">function</span>(view, options, fn){
  options = options || {};
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;
  <span class="keyword">var</span> app = req.app;

  <span class="comment">// support callback function as second arg</span>
  <span class="keyword">if</span> (<span class="string">'function'</span> == <span class="keyword">typeof</span> options) {
    fn = options, options = {};
  }

  <span class="comment">// merge res.locals</span>
  options._locals = self.locals;

  <span class="comment">// default callback to respond</span>
  fn = fn || <span class="keyword">function</span>(err, str){
    <span class="keyword">if</span> (err) <span class="keyword">return</span> req.next(err);
    self.send(str);
  };

  <span class="comment">// render</span>
  app.render(view, options, fn);
};

<span class="comment">// pipe the send file stream</span>
<span class="function"><span class="keyword">function</span> <span class="title">sendfile</span><span class="params">(res, file, options, callback)</span> {</span>
  <span class="keyword">var</span> done = <span class="literal">false</span>;

  <span class="comment">// directory</span>
  <span class="function"><span class="keyword">function</span> <span class="title">ondirectory</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (done) <span class="keyword">return</span>;
    done = <span class="literal">true</span>;

    <span class="keyword">var</span> err = <span class="keyword">new</span> Error(<span class="string">'EISDIR, read'</span>);
    err.code = <span class="string">'EISDIR'</span>;
    callback(err);
  }

  <span class="comment">// errors</span>
  <span class="function"><span class="keyword">function</span> <span class="title">onerror</span><span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (done) <span class="keyword">return</span>;
    done = <span class="literal">true</span>;
    callback(err);
  }

  <span class="comment">// ended</span>
  <span class="function"><span class="keyword">function</span> <span class="title">onend</span><span class="params">()</span> {</span>
    <span class="keyword">if</span> (done) <span class="keyword">return</span>;
    done = <span class="literal">true</span>;
    callback();
  }

  <span class="comment">// finished</span>
  <span class="function"><span class="keyword">function</span> <span class="title">onfinish</span><span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (err) <span class="keyword">return</span> onerror(err);
    <span class="keyword">if</span> (done) <span class="keyword">return</span>;

    setImmediate(<span class="function"><span class="keyword">function</span> <span class="params">()</span> {</span>
      <span class="keyword">if</span> (done) <span class="keyword">return</span>;
      done = <span class="literal">true</span>;

      <span class="comment">// response finished before end of file</span>
      <span class="keyword">var</span> err = <span class="keyword">new</span> Error(<span class="string">'Request aborted'</span>);
      err.code = <span class="string">'ECONNABORT'</span>;
      callback(err);
    });
  }

  file.on(<span class="string">'end'</span>, onend);
  file.on(<span class="string">'error'</span>, onerror);
  file.on(<span class="string">'directory'</span>, ondirectory);
  onFinished(res, onfinish);

  <span class="keyword">if</span> (options.headers) {
    <span class="comment">// set headers on successful transfer</span>
    file.on(<span class="string">'headers'</span>, <span class="function"><span class="keyword">function</span> <span class="title">headers</span><span class="params">(res)</span> {</span>
      <span class="keyword">var</span> obj = options.headers;
      <span class="keyword">var</span> keys = Object.keys(obj);

      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++) {
        <span class="keyword">var</span> k = keys[i];
        res.setHeader(k, obj[k]);
      }
    });
  }

  <span class="comment">// pipe</span>
  file.pipe(res);
}
</code></pre>