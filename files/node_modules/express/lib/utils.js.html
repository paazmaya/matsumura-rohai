<h1>utils.js</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Module dependencies.
 */</span>

<span class="keyword">var</span> mime = require(<span class="string">'send'</span>).mime;
<span class="keyword">var</span> basename = require(<span class="string">'path'</span>).basename;
<span class="keyword">var</span> etag = require(<span class="string">'etag'</span>);
<span class="keyword">var</span> proxyaddr = require(<span class="string">'proxy-addr'</span>);
<span class="keyword">var</span> qs = require(<span class="string">'qs'</span>);
<span class="keyword">var</span> querystring = require(<span class="string">'querystring'</span>);
<span class="keyword">var</span> typer = require(<span class="string">'media-typer'</span>);

<span class="comment">/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */</span>

exports.etag = <span class="function"><span class="keyword">function</span> <span class="params">(body, encoding)</span> {</span>
  <span class="keyword">var</span> buf = !Buffer.isBuffer(body)
    ? <span class="keyword">new</span> Buffer(body, encoding)
    : body

  <span class="keyword">return</span> etag(buf, {weak: <span class="literal">false</span>})
};

<span class="comment">/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */</span>

exports.wetag = <span class="function"><span class="keyword">function</span> <span class="title">wetag</span><span class="params">(body, encoding)</span>{</span>
  <span class="keyword">var</span> buf = !Buffer.isBuffer(body)
    ? <span class="keyword">new</span> Buffer(body, encoding)
    : body

  <span class="keyword">return</span> etag(buf, {weak: <span class="literal">true</span>})
};

<span class="comment">/**
 * Check if `path` looks absolute.
 *
 * @param {String} path
 * @return {Boolean}
 * @api private
 */</span>

exports.isAbsolute = <span class="keyword">function</span>(path){
  <span class="keyword">if</span> (<span class="string">'/'</span> == path[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">true</span>;
  <span class="keyword">if</span> (<span class="string">':'</span> == path[<span class="number">1</span>] &amp;&amp; <span class="string">'\\'</span> == path[<span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;
  <span class="keyword">if</span> (<span class="string">'\\\\'</span> == path.substring(<span class="number">0</span>, <span class="number">2</span>)) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// Microsoft Azure absolute path</span>
};

<span class="comment">/**
 * Flatten the given `arr`.
 *
 * @param {Array} arr
 * @return {Array}
 * @api private
 */</span>

exports.flatten = <span class="keyword">function</span>(arr, ret){
  ret = ret || [];
  <span class="keyword">var</span> len = arr.length;
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; ++i) {
    <span class="keyword">if</span> (Array.isArray(arr[i])) {
      exports.flatten(arr[i], ret);
    } <span class="keyword">else</span> {
      ret.push(arr[i]);
    }
  }
  <span class="keyword">return</span> ret;
};

<span class="comment">/**
 * Normalize the given `type`, for example "html" becomes "text/html".
 *
 * @param {String} type
 * @return {Object}
 * @api private
 */</span>

exports.normalizeType = <span class="keyword">function</span>(type){
  <span class="keyword">return</span> ~type.indexOf(<span class="string">'/'</span>)
    ? acceptParams(type)
    : { value: mime.lookup(type), params: {} };
};

<span class="comment">/**
 * Normalize `types`, for example "html" becomes "text/html".
 *
 * @param {Array} types
 * @return {Array}
 * @api private
 */</span>

exports.normalizeTypes = <span class="keyword">function</span>(types){
  <span class="keyword">var</span> ret = [];

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; types.length; ++i) {
    ret.push(exports.normalizeType(types[i]));
  }

  <span class="keyword">return</span> ret;
};

<span class="comment">/**
 * Generate Content-Disposition header appropriate for the filename.
 * non-ascii filenames are urlencoded and a filename* parameter is added
 *
 * @param {String} filename
 * @return {String}
 * @api private
 */</span>

exports.contentDisposition = <span class="keyword">function</span>(filename){
  <span class="keyword">var</span> ret = <span class="string">'attachment'</span>;
  <span class="keyword">if</span> (filename) {
    filename = basename(filename);
    <span class="comment">// if filename contains non-ascii characters, add a utf-8 version ala RFC 5987</span>
    ret = <span class="regexp">/[^\040-\176]/</span>.test(filename)
      ? <span class="string">'attachment; filename="'</span> + encodeURI(filename) + <span class="string">'"; filename*=UTF-8\'\''</span> + encodeURI(filename)
      : <span class="string">'attachment; filename="'</span> + filename + <span class="string">'"'</span>;
  }

  <span class="keyword">return</span> ret;
};

<span class="comment">/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">acceptParams</span><span class="params">(str, index)</span> {</span>
  <span class="keyword">var</span> parts = str.split(<span class="regexp">/ *; */</span>);
  <span class="keyword">var</span> ret = { value: parts[<span class="number">0</span>], quality: <span class="number">1</span>, params: {}, originalIndex: index };

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; parts.length; ++i) {
    <span class="keyword">var</span> pms = parts[i].split(<span class="regexp">/ *= */</span>);
    <span class="keyword">if</span> (<span class="string">'q'</span> == pms[<span class="number">0</span>]) {
      ret.quality = parseFloat(pms[<span class="number">1</span>]);
    } <span class="keyword">else</span> {
      ret.params[pms[<span class="number">0</span>]] = pms[<span class="number">1</span>];
    }
  }

  <span class="keyword">return</span> ret;
}

<span class="comment">/**
 * Compile "etag" value to function.
 *
 * @param  {Boolean|String|Function} val
 * @return {Function}
 * @api private
 */</span>

exports.compileETag = <span class="keyword">function</span>(val) {
  <span class="keyword">var</span> fn;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'function'</span>) {
    <span class="keyword">return</span> val;
  }

  <span class="keyword">switch</span> (val) {
    <span class="keyword">case</span> <span class="literal">true</span>:
      fn = exports.wetag;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="literal">false</span>:
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'strong'</span>:
      fn = exports.etag;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'weak'</span>:
      fn = exports.wetag;
      <span class="keyword">break</span>;
    <span class="keyword">default</span>:
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'unknown value for etag function: '</span> + val);
  }

  <span class="keyword">return</span> fn;
}

<span class="comment">/**
 * Compile "query parser" value to function.
 *
 * @param  {String|Function} val
 * @return {Function}
 * @api private
 */</span>

exports.compileQueryParser = <span class="function"><span class="keyword">function</span> <span class="title">compileQueryParser</span><span class="params">(val)</span> {</span>
  <span class="keyword">var</span> fn;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'function'</span>) {
    <span class="keyword">return</span> val;
  }

  <span class="keyword">switch</span> (val) {
    <span class="keyword">case</span> <span class="literal">true</span>:
      fn = querystring.parse;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="literal">false</span>:
      fn = newObject;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'extended'</span>:
      fn = qs.parse;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'simple'</span>:
      fn = querystring.parse;
      <span class="keyword">break</span>;
    <span class="keyword">default</span>:
      <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'unknown value for query parser function: '</span> + val);
  }

  <span class="keyword">return</span> fn;
}

<span class="comment">/**
 * Compile "proxy trust" value to function.
 *
 * @param  {Boolean|String|Number|Array|Function} val
 * @return {Function}
 * @api private
 */</span>

exports.compileTrust = <span class="keyword">function</span>(val) {
  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'function'</span>) <span class="keyword">return</span> val;

  <span class="keyword">if</span> (val === <span class="literal">true</span>) {
    <span class="comment">// Support plain true/false</span>
    <span class="keyword">return</span> <span class="keyword">function</span>(){ <span class="keyword">return</span> <span class="literal">true</span> };
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'number'</span>) {
    <span class="comment">// Support trusting hop count</span>
    <span class="keyword">return</span> <span class="keyword">function</span>(a, i){ <span class="keyword">return</span> i &lt; val };
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">'string'</span>) {
    <span class="comment">// Support comma-separated values</span>
    val = val.split(<span class="regexp">/ *, */</span>);
  }

  <span class="keyword">return</span> proxyaddr.compile(val || []);
}

<span class="comment">/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */</span>

exports.setCharset = <span class="keyword">function</span>(type, charset){
  <span class="keyword">if</span> (!type || !charset) <span class="keyword">return</span> type;

  <span class="comment">// parse type</span>
  <span class="keyword">var</span> parsed = typer.parse(type);

  <span class="comment">// set charset</span>
  parsed.parameters.charset = charset;

  <span class="comment">// format type</span>
  <span class="keyword">return</span> typer.format(parsed);
};

<span class="comment">/**
 * Return new empty objet.
 *
 * @return {Object}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">newObject</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> {};
}
</code></pre>