<h1>send</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Module dependencies.
 */</span>

<span class="keyword">var</span> debug = require(<span class="string">'debug'</span>)(<span class="string">'send'</span>)
<span class="keyword">var</span> deprecate = require(<span class="string">'depd'</span>)(<span class="string">'send'</span>)
<span class="keyword">var</span> destroy = require(<span class="string">'destroy'</span>)
<span class="keyword">var</span> escapeHtml = require(<span class="string">'escape-html'</span>)
  , parseRange = require(<span class="string">'range-parser'</span>)
  , Stream = require(<span class="string">'stream'</span>)
  , mime = require(<span class="string">'mime'</span>)
  , fresh = require(<span class="string">'fresh'</span>)
  , path = require(<span class="string">'path'</span>)
  , http = require(<span class="string">'http'</span>)
  , fs = require(<span class="string">'fs'</span>)
  , normalize = path.normalize
  , join = path.join
<span class="keyword">var</span> etag = require(<span class="string">'etag'</span>)
<span class="keyword">var</span> EventEmitter = require(<span class="string">'events'</span>).EventEmitter;
<span class="keyword">var</span> ms = require(<span class="string">'ms'</span>);
<span class="keyword">var</span> onFinished = require(<span class="string">'on-finished'</span>)

<span class="comment">/**
 * Variables.
 */</span>
<span class="keyword">var</span> extname = path.extname
<span class="keyword">var</span> maxMaxAge = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">1000</span>; <span class="comment">// 1 year</span>
<span class="keyword">var</span> resolve = path.resolve
<span class="keyword">var</span> sep = path.sep
<span class="keyword">var</span> toString = Object.prototype.toString
<span class="keyword">var</span> upPathRegexp = <span class="regexp">/(?:^|[\\\/])\.\.(?:[\\\/]|$)/</span>

<span class="comment">/**
 * Expose `send`.
 */</span>

exports = module.exports = send;

<span class="comment">/**
 * Expose mime module.
 */</span>

exports.mime = mime;

<span class="comment">/**
 * Shim EventEmitter.listenerCount for node.js &lt; 0.10
 */</span>

<span class="comment">/* istanbul ignore next */</span>
<span class="keyword">var</span> listenerCount = EventEmitter.listenerCount
  || <span class="keyword">function</span>(emitter, type){ <span class="keyword">return</span> emitter.listeners(type).length; };

<span class="comment">/**
 * Return a `SendStream` for `req` and `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {Object} options
 * @return {SendStream}
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">send</span><span class="params">(req, path, options)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">new</span> SendStream(req, path, options);
}

<span class="comment">/**
 * Initialize a `SendStream` with the given `path`.
 *
 * @param {Request} req
 * @param {String} path
 * @param {Object} options
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">SendStream</span><span class="params">(req, path, options)</span> {</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  options = options || {};
  <span class="keyword">this</span>.req = req;
  <span class="keyword">this</span>.path = path;
  <span class="keyword">this</span>.options = options;

  <span class="keyword">this</span>._etag = options.etag !== <span class="literal">undefined</span>
    ? Boolean(options.etag)
    : <span class="literal">true</span>

  <span class="keyword">this</span>._dotfiles = options.dotfiles !== <span class="literal">undefined</span>
    ? options.dotfiles
    : <span class="string">'ignore'</span>

  <span class="keyword">if</span> ([<span class="string">'allow'</span>, <span class="string">'deny'</span>, <span class="string">'ignore'</span>].indexOf(<span class="keyword">this</span>._dotfiles) === -<span class="number">1</span>) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'dotfiles option must be "allow", "deny", or "ignore"'</span>)
  }

  <span class="keyword">this</span>._hidden = Boolean(options.hidden)

  <span class="keyword">if</span> (<span class="string">'hidden'</span> <span class="keyword">in</span> options) {
    deprecate(<span class="string">'hidden: use dotfiles: \''</span> + (<span class="keyword">this</span>._hidden ? <span class="string">'allow'</span> : <span class="string">'ignore'</span>) + <span class="string">'\' instead'</span>)
  }

  <span class="comment">// legacy support</span>
  <span class="keyword">if</span> (!(<span class="string">'dotfiles'</span> <span class="keyword">in</span> options)) {
    <span class="keyword">this</span>._dotfiles = <span class="literal">undefined</span>
  }

  <span class="keyword">this</span>._extensions = options.extensions !== <span class="literal">undefined</span>
    ? normalizeList(options.extensions)
    : []

  <span class="keyword">this</span>._index = options.index !== <span class="literal">undefined</span>
    ? normalizeList(options.index)
    : [<span class="string">'index.html'</span>]

  <span class="keyword">this</span>._lastModified = options.lastModified !== <span class="literal">undefined</span>
    ? Boolean(options.lastModified)
    : <span class="literal">true</span>

  <span class="keyword">this</span>._maxage = options.maxAge || options.maxage
  <span class="keyword">this</span>._maxage = <span class="keyword">typeof</span> <span class="keyword">this</span>._maxage === <span class="string">'string'</span>
    ? ms(<span class="keyword">this</span>._maxage)
    : Number(<span class="keyword">this</span>._maxage)
  <span class="keyword">this</span>._maxage = !isNaN(<span class="keyword">this</span>._maxage)
    ? Math.min(Math.max(<span class="number">0</span>, <span class="keyword">this</span>._maxage), maxMaxAge)
    : <span class="number">0</span>

  <span class="keyword">this</span>._root = options.root
    ? resolve(options.root)
    : <span class="literal">null</span>

  <span class="keyword">if</span> (!<span class="keyword">this</span>._root &amp;&amp; options.from) {
    <span class="keyword">this</span>.from(options.from);
  }
}

<span class="comment">/**
 * Inherits from `Stream.prototype`.
 */</span>

SendStream.prototype.__proto__ = Stream.prototype;

<span class="comment">/**
 * Enable or disable etag generation.
 *
 * @param {Boolean} val
 * @return {SendStream}
 * @api public
 */</span>

SendStream.prototype.etag = deprecate.<span class="keyword">function</span>(<span class="function"><span class="keyword">function</span> <span class="title">etag</span><span class="params">(val)</span> {</span>
  val = Boolean(val);
  debug(<span class="string">'etag %s'</span>, val);
  <span class="keyword">this</span>._etag = val;
  <span class="keyword">return</span> <span class="keyword">this</span>;
}, <span class="string">'send.etag: pass etag as option'</span>);

<span class="comment">/**
 * Enable or disable "hidden" (dot) files.
 *
 * @param {Boolean} path
 * @return {SendStream}
 * @api public
 */</span>

SendStream.prototype.hidden = deprecate.<span class="keyword">function</span>(<span class="function"><span class="keyword">function</span> <span class="title">hidden</span><span class="params">(val)</span> {</span>
  val = Boolean(val);
  debug(<span class="string">'hidden %s'</span>, val);
  <span class="keyword">this</span>._hidden = val;
  <span class="keyword">this</span>._dotfiles = <span class="literal">undefined</span>
  <span class="keyword">return</span> <span class="keyword">this</span>;
}, <span class="string">'send.hidden: use dotfiles option'</span>);

<span class="comment">/**
 * Set index `paths`, set to a falsy
 * value to disable index support.
 *
 * @param {String|Boolean|Array} paths
 * @return {SendStream}
 * @api public
 */</span>

SendStream.prototype.index = deprecate.<span class="keyword">function</span>(<span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">(paths)</span> {</span>
  <span class="keyword">var</span> index = !paths ? [] : normalizeList(paths);
  debug(<span class="string">'index %o'</span>, paths);
  <span class="keyword">this</span>._index = index;
  <span class="keyword">return</span> <span class="keyword">this</span>;
}, <span class="string">'send.index: pass index as option'</span>);

<span class="comment">/**
 * Set root `path`.
 *
 * @param {String} path
 * @return {SendStream}
 * @api public
 */</span>

SendStream.prototype.root = <span class="keyword">function</span>(path){
  path = String(path);
  <span class="keyword">this</span>._root = resolve(path)
  <span class="keyword">return</span> <span class="keyword">this</span>;
};

SendStream.prototype.from = deprecate.<span class="keyword">function</span>(SendStream.prototype.root,
  <span class="string">'send.from: pass root as option'</span>);

SendStream.prototype.root = deprecate.<span class="keyword">function</span>(SendStream.prototype.root,
  <span class="string">'send.root: pass root as option'</span>);

<span class="comment">/**
 * Set max-age to `maxAge`.
 *
 * @param {Number} maxAge
 * @return {SendStream}
 * @api public
 */</span>

SendStream.prototype.maxage = deprecate.<span class="keyword">function</span>(<span class="function"><span class="keyword">function</span> <span class="title">maxage</span><span class="params">(maxAge)</span> {</span>
  maxAge = <span class="keyword">typeof</span> maxAge === <span class="string">'string'</span>
    ? ms(maxAge)
    : Number(maxAge);
  <span class="keyword">if</span> (isNaN(maxAge)) maxAge = <span class="number">0</span>;
  <span class="keyword">if</span> (<span class="literal">Infinity</span> == maxAge) maxAge = <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">1000</span>;
  debug(<span class="string">'max-age %d'</span>, maxAge);
  <span class="keyword">this</span>._maxage = maxAge;
  <span class="keyword">return</span> <span class="keyword">this</span>;
}, <span class="string">'send.maxage: pass maxAge as option'</span>);

<span class="comment">/**
 * Emit error with `status`.
 *
 * @param {Number} status
 * @api private
 */</span>

SendStream.prototype.error = <span class="keyword">function</span>(status, err){
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;
  <span class="keyword">var</span> msg = http.STATUS_CODES[status];

  err = err || <span class="keyword">new</span> Error(msg);
  err.status = status;

  <span class="comment">// emit if listeners instead of responding</span>
  <span class="keyword">if</span> (listenerCount(<span class="keyword">this</span>, <span class="string">'error'</span>) !== <span class="number">0</span>) {
    <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err);
  }

  <span class="comment">// wipe all existing headers</span>
  res._headers = <span class="literal">undefined</span>;

  res.statusCode = err.status;
  res.end(msg);
};

<span class="comment">/**
 * Check if the pathname ends with "/".
 *
 * @return {Boolean}
 * @api private
 */</span>

SendStream.prototype.hasTrailingSlash = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="string">'/'</span> == <span class="keyword">this</span>.path[<span class="keyword">this</span>.path.length - <span class="number">1</span>];
};

<span class="comment">/**
 * Check if this is a conditional GET request.
 *
 * @return {Boolean}
 * @api private
 */</span>

SendStream.prototype.isConditionalGET = <span class="keyword">function</span>(){
  <span class="keyword">return</span> <span class="keyword">this</span>.req.headers[<span class="string">'if-none-match'</span>]
    || <span class="keyword">this</span>.req.headers[<span class="string">'if-modified-since'</span>];
};

<span class="comment">/**
 * Strip content-* header fields.
 *
 * @api private
 */</span>

SendStream.prototype.removeContentHeaderFields = <span class="keyword">function</span>(){
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;
  Object.keys(res._headers).forEach(<span class="keyword">function</span>(field){
    <span class="keyword">if</span> (<span class="number">0</span> == field.indexOf(<span class="string">'content'</span>)) {
      res.removeHeader(field);
    }
  });
};

<span class="comment">/**
 * Respond with 304 not modified.
 *
 * @api private
 */</span>

SendStream.prototype.notModified = <span class="keyword">function</span>(){
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;
  debug(<span class="string">'not modified'</span>);
  <span class="keyword">this</span>.removeContentHeaderFields();
  res.statusCode = <span class="number">304</span>;
  res.end();
};

<span class="comment">/**
 * Raise error that headers already sent.
 *
 * @api private
 */</span>

SendStream.prototype.headersAlreadySent = <span class="function"><span class="keyword">function</span> <span class="title">headersAlreadySent</span><span class="params">()</span>{</span>
  <span class="keyword">var</span> err = <span class="keyword">new</span> Error(<span class="string">'Can\'t set headers after they are sent.'</span>);
  debug(<span class="string">'headers already sent'</span>);
  <span class="keyword">this</span>.error(<span class="number">500</span>, err);
};

<span class="comment">/**
 * Check if the request is cacheable, aka
 * responded with 2xx or 304 (see RFC 2616 section 14.2{5,6}).
 *
 * @return {Boolean}
 * @api private
 */</span>

SendStream.prototype.isCachable = <span class="keyword">function</span>(){
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;
  <span class="keyword">return</span> (res.statusCode >= <span class="number">200</span> &amp;&amp; res.statusCode &lt; <span class="number">300</span>) || <span class="number">304</span> == res.statusCode;
};

<span class="comment">/**
 * Handle stat() error.
 *
 * @param {Error} err
 * @api private
 */</span>

SendStream.prototype.onStatError = <span class="keyword">function</span>(err){
  <span class="keyword">var</span> notfound = [<span class="string">'ENOENT'</span>, <span class="string">'ENAMETOOLONG'</span>, <span class="string">'ENOTDIR'</span>];
  <span class="keyword">if</span> (~notfound.indexOf(err.code)) <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">404</span>, err);
  <span class="keyword">this</span>.error(<span class="number">500</span>, err);
};

<span class="comment">/**
 * Check if the cache is fresh.
 *
 * @return {Boolean}
 * @api private
 */</span>

SendStream.prototype.isFresh = <span class="keyword">function</span>(){
  <span class="keyword">return</span> fresh(<span class="keyword">this</span>.req.headers, <span class="keyword">this</span>.res._headers);
};

<span class="comment">/**
 * Check if the range is fresh.
 *
 * @return {Boolean}
 * @api private
 */</span>

SendStream.prototype.isRangeFresh = <span class="function"><span class="keyword">function</span> <span class="title">isRangeFresh</span><span class="params">()</span>{</span>
  <span class="keyword">var</span> ifRange = <span class="keyword">this</span>.req.headers[<span class="string">'if-range'</span>];

  <span class="keyword">if</span> (!ifRange) <span class="keyword">return</span> <span class="literal">true</span>;

  <span class="keyword">return</span> ~ifRange.indexOf(<span class="string">'"'</span>)
    ? ~ifRange.indexOf(<span class="keyword">this</span>.res._headers[<span class="string">'etag'</span>])
    : Date.parse(<span class="keyword">this</span>.res._headers[<span class="string">'last-modified'</span>]) &lt;= Date.parse(ifRange);
};

<span class="comment">/**
 * Redirect to `path`.
 *
 * @param {String} path
 * @api private
 */</span>

SendStream.prototype.redirect = <span class="keyword">function</span>(path){
  <span class="keyword">if</span> (listenerCount(<span class="keyword">this</span>, <span class="string">'directory'</span>) !== <span class="number">0</span>) {
    <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'directory'</span>);
  }

  <span class="keyword">if</span> (<span class="keyword">this</span>.hasTrailingSlash()) <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">403</span>);
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;
  path += <span class="string">'/'</span>;
  res.statusCode = <span class="number">301</span>;
  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf-8'</span>);
  res.setHeader(<span class="string">'Location'</span>, path);
  res.end(<span class="string">'Redirecting to &lt;a href="'</span> + escapeHtml(path) + <span class="string">'">'</span> + escapeHtml(path) + <span class="string">'&lt;/a>\n'</span>);
};

<span class="comment">/**
 * Pipe to `res.
 *
 * @param {Stream} res
 * @return {Stream} res
 * @api public
 */</span>

SendStream.prototype.pipe = <span class="keyword">function</span>(res){
  <span class="keyword">var</span> self = <span class="keyword">this</span>
    , args = arguments
    , root = <span class="keyword">this</span>._root;

  <span class="comment">// references</span>
  <span class="keyword">this</span>.res = res;

  <span class="comment">// decode the path</span>
  <span class="keyword">var</span> path = decode(<span class="keyword">this</span>.path)
  <span class="keyword">if</span> (path === -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">400</span>)

  <span class="comment">// null byte(s)</span>
  <span class="keyword">if</span> (~path.indexOf(<span class="string">'\0'</span>)) <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">400</span>);

  <span class="keyword">var</span> parts
  <span class="keyword">if</span> (root !== <span class="literal">null</span>) {
    <span class="comment">// join / normalize from optional root dir</span>
    path = normalize(join(root, path))
    root = normalize(root + sep)

    <span class="comment">// malicious path</span>
    <span class="keyword">if</span> ((path + sep).substr(<span class="number">0</span>, root.length) !== root) {
      debug(<span class="string">'malicious path "%s"'</span>, path)
      <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">403</span>)
    }

    <span class="comment">// explode path parts</span>
    parts = path.substr(root.length).split(sep)
  } <span class="keyword">else</span> {
    <span class="comment">// ".." is malicious without "root"</span>
    <span class="keyword">if</span> (upPathRegexp.test(path)) {
      debug(<span class="string">'malicious path "%s"'</span>, path)
      <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">403</span>)
    }

    <span class="comment">// explode path parts</span>
    parts = normalize(path).split(sep)

    <span class="comment">// resolve the path</span>
    path = resolve(path)
  }

  <span class="comment">// dotfile handling</span>
  <span class="keyword">if</span> (containsDotFile(parts)) {
    <span class="keyword">var</span> access = <span class="keyword">this</span>._dotfiles

    <span class="comment">// legacy support</span>
    <span class="keyword">if</span> (access === <span class="literal">undefined</span>) {
      access = parts[parts.length - <span class="number">1</span>][<span class="number">0</span>] === <span class="string">'.'</span>
        ? (<span class="keyword">this</span>._hidden ? <span class="string">'allow'</span> : <span class="string">'ignore'</span>)
        : <span class="string">'allow'</span>
    }

    debug(<span class="string">'%s dotfile "%s"'</span>, access, path)
    <span class="keyword">switch</span> (access) {
      <span class="keyword">case</span> <span class="string">'allow'</span>:
        <span class="keyword">break</span>
      <span class="keyword">case</span> <span class="string">'deny'</span>:
        <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">403</span>)
      <span class="keyword">case</span> <span class="string">'ignore'</span>:
      <span class="keyword">default</span>:
        <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">404</span>)
    }
  }

  <span class="comment">// index file support</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>._index.length &amp;&amp; <span class="keyword">this</span>.path[<span class="keyword">this</span>.path.length - <span class="number">1</span>] === <span class="string">'/'</span>) {
    <span class="keyword">this</span>.sendIndex(path);
    <span class="keyword">return</span> res;
  }

  <span class="keyword">this</span>.sendFile(path);
  <span class="keyword">return</span> res;
};

<span class="comment">/**
 * Transfer `path`.
 *
 * @param {String} path
 * @api public
 */</span>

SendStream.prototype.send = <span class="keyword">function</span>(path, stat){
  <span class="keyword">var</span> options = <span class="keyword">this</span>.options;
  <span class="keyword">var</span> len = stat.size;
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;
  <span class="keyword">var</span> ranges = req.headers.range;
  <span class="keyword">var</span> offset = options.start || <span class="number">0</span>;

  <span class="keyword">if</span> (res._header) {
    <span class="comment">// impossible to send now</span>
    <span class="keyword">return</span> <span class="keyword">this</span>.headersAlreadySent();
  }

  debug(<span class="string">'pipe "%s"'</span>, path)

  <span class="comment">// set header fields</span>
  <span class="keyword">this</span>.setHeader(path, stat);

  <span class="comment">// set content-type</span>
  <span class="keyword">this</span>.type(path);

  <span class="comment">// conditional GET support</span>
  <span class="keyword">if</span> (<span class="keyword">this</span>.isConditionalGET()
    &amp;&amp; <span class="keyword">this</span>.isCachable()
    &amp;&amp; <span class="keyword">this</span>.isFresh()) {
    <span class="keyword">return</span> <span class="keyword">this</span>.notModified();
  }

  <span class="comment">// adjust len to start/end options</span>
  len = Math.max(<span class="number">0</span>, len - offset);
  <span class="keyword">if</span> (options.end !== <span class="literal">undefined</span>) {
    <span class="keyword">var</span> bytes = options.end - offset + <span class="number">1</span>;
    <span class="keyword">if</span> (len > bytes) len = bytes;
  }

  <span class="comment">// Range support</span>
  <span class="keyword">if</span> (ranges) {
    ranges = parseRange(len, ranges);

    <span class="comment">// If-Range support</span>
    <span class="keyword">if</span> (!<span class="keyword">this</span>.isRangeFresh()) {
      debug(<span class="string">'range stale'</span>);
      ranges = -<span class="number">2</span>;
    }

    <span class="comment">// unsatisfiable</span>
    <span class="keyword">if</span> (-<span class="number">1</span> == ranges) {
      debug(<span class="string">'range unsatisfiable'</span>);
      res.setHeader(<span class="string">'Content-Range'</span>, <span class="string">'bytes */'</span> + stat.size);
      <span class="keyword">return</span> <span class="keyword">this</span>.error(<span class="number">416</span>);
    }

    <span class="comment">// valid (syntactically invalid/multiple ranges are treated as a regular response)</span>
    <span class="keyword">if</span> (-<span class="number">2</span> != ranges &amp;&amp; ranges.length === <span class="number">1</span>) {
      debug(<span class="string">'range %j'</span>, ranges);

      options.start = offset + ranges[<span class="number">0</span>].start;
      options.end = offset + ranges[<span class="number">0</span>].end;

      <span class="comment">// Content-Range</span>
      res.statusCode = <span class="number">206</span>;
      res.setHeader(<span class="string">'Content-Range'</span>, <span class="string">'bytes '</span>
        + ranges[<span class="number">0</span>].start
        + <span class="string">'-'</span>
        + ranges[<span class="number">0</span>].end
        + <span class="string">'/'</span>
        + len);
      len = options.end - options.start + <span class="number">1</span>;
    }
  }

  <span class="comment">// content-length</span>
  res.setHeader(<span class="string">'Content-Length'</span>, len);

  <span class="comment">// HEAD support</span>
  <span class="keyword">if</span> (<span class="string">'HEAD'</span> == req.method) <span class="keyword">return</span> res.end();

  <span class="keyword">this</span>.stream(path, options);
};

<span class="comment">/**
 * Transfer file for `path`.
 *
 * @param {String} path
 * @api private
 */</span>
SendStream.prototype.sendFile = <span class="function"><span class="keyword">function</span> <span class="title">sendFile</span><span class="params">(path)</span> {</span>
  <span class="keyword">var</span> i = <span class="number">0</span>
  <span class="keyword">var</span> self = <span class="keyword">this</span>

  debug(<span class="string">'stat "%s"'</span>, path);
  fs.stat(path, <span class="function"><span class="keyword">function</span> <span class="title">onstat</span><span class="params">(err, stat)</span> {</span>
    <span class="keyword">if</span> (err &amp;&amp; err.code === <span class="string">'ENOENT'</span>
      &amp;&amp; !extname(path)
      &amp;&amp; path[path.length - <span class="number">1</span>] !== sep) {
      <span class="comment">// not found, check extensions</span>
      <span class="keyword">return</span> next(err)
    }
    <span class="keyword">if</span> (err) <span class="keyword">return</span> self.onStatError(err)
    <span class="keyword">if</span> (stat.isDirectory()) <span class="keyword">return</span> self.redirect(self.path)
    self.emit(<span class="string">'file'</span>, path, stat)
    self.send(path, stat)
  })

  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err)</span> {</span>
    <span class="keyword">if</span> (self._extensions.length &lt;= i) {
      <span class="keyword">return</span> err
        ? self.onStatError(err)
        : self.error(<span class="number">404</span>)
    }

    <span class="keyword">var</span> p = path + <span class="string">'.'</span> + self._extensions[i++]

    debug(<span class="string">'stat "%s"'</span>, p)
    fs.stat(p, <span class="function"><span class="keyword">function</span> <span class="params">(err, stat)</span> {</span>
      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err)
      <span class="keyword">if</span> (stat.isDirectory()) <span class="keyword">return</span> next()
      self.emit(<span class="string">'file'</span>, p, stat)
      self.send(p, stat)
    })
  }
}

<span class="comment">/**
 * Transfer index for `path`.
 *
 * @param {String} path
 * @api private
 */</span>
SendStream.prototype.sendIndex = <span class="function"><span class="keyword">function</span> <span class="title">sendIndex</span><span class="params">(path)</span>{</span>
  <span class="keyword">var</span> i = -<span class="number">1</span>;
  <span class="keyword">var</span> self = <span class="keyword">this</span>;

  <span class="function"><span class="keyword">function</span> <span class="title">next</span><span class="params">(err)</span>{</span>
    <span class="keyword">if</span> (++i >= self._index.length) {
      <span class="keyword">if</span> (err) <span class="keyword">return</span> self.onStatError(err);
      <span class="keyword">return</span> self.error(<span class="number">404</span>);
    }

    <span class="keyword">var</span> p = join(path, self._index[i]);

    debug(<span class="string">'stat "%s"'</span>, p);
    fs.stat(p, <span class="keyword">function</span>(err, stat){
      <span class="keyword">if</span> (err) <span class="keyword">return</span> next(err);
      <span class="keyword">if</span> (stat.isDirectory()) <span class="keyword">return</span> next();
      self.emit(<span class="string">'file'</span>, p, stat);
      self.send(p, stat);
    });
  }

  next();
};

<span class="comment">/**
 * Stream `path` to the response.
 *
 * @param {String} path
 * @param {Object} options
 * @api private
 */</span>

SendStream.prototype.stream = <span class="keyword">function</span>(path, options){
  <span class="comment">// TODO: this is all lame, refactor meeee</span>
  <span class="keyword">var</span> finished = <span class="literal">false</span>;
  <span class="keyword">var</span> self = <span class="keyword">this</span>;
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;
  <span class="keyword">var</span> req = <span class="keyword">this</span>.req;

  <span class="comment">// pipe</span>
  <span class="keyword">var</span> stream = fs.createReadStream(path, options);
  <span class="keyword">this</span>.emit(<span class="string">'stream'</span>, stream);
  stream.pipe(res);

  <span class="comment">// response finished, done with the fd</span>
  onFinished(res, <span class="function"><span class="keyword">function</span> <span class="title">onfinished</span><span class="params">()</span>{</span>
    finished = <span class="literal">true</span>;
    destroy(stream);
  });

  <span class="comment">// error handling code-smell</span>
  stream.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onerror</span><span class="params">(err)</span>{</span>
    <span class="comment">// request already finished</span>
    <span class="keyword">if</span> (finished) <span class="keyword">return</span>;

    <span class="comment">// clean up stream</span>
    finished = <span class="literal">true</span>;
    destroy(stream);

    <span class="comment">// error</span>
    self.onStatError(err);
  });

  <span class="comment">// end</span>
  stream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> <span class="title">onend</span><span class="params">()</span>{</span>
    self.emit(<span class="string">'end'</span>);
  });
};

<span class="comment">/**
 * Set content-type based on `path`
 * if it hasn't been explicitly set.
 *
 * @param {String} path
 * @api private
 */</span>

SendStream.prototype.type = <span class="keyword">function</span>(path){
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;
  <span class="keyword">if</span> (res.getHeader(<span class="string">'Content-Type'</span>)) <span class="keyword">return</span>;
  <span class="keyword">var</span> type = mime.lookup(path);
  <span class="keyword">var</span> charset = mime.charsets.lookup(type);
  debug(<span class="string">'content-type %s'</span>, type);
  res.setHeader(<span class="string">'Content-Type'</span>, type + (charset ? <span class="string">'; charset='</span> + charset : <span class="string">''</span>));
};

<span class="comment">/**
 * Set response header fields, most
 * fields may be pre-defined.
 *
 * @param {String} path
 * @param {Object} stat
 * @api private
 */</span>

SendStream.prototype.setHeader = <span class="function"><span class="keyword">function</span> <span class="title">setHeader</span><span class="params">(path, stat)</span>{</span>
  <span class="keyword">var</span> res = <span class="keyword">this</span>.res;

  <span class="keyword">this</span>.emit(<span class="string">'headers'</span>, res, path, stat);

  <span class="keyword">if</span> (!res.getHeader(<span class="string">'Accept-Ranges'</span>)) res.setHeader(<span class="string">'Accept-Ranges'</span>, <span class="string">'bytes'</span>);
  <span class="keyword">if</span> (!res.getHeader(<span class="string">'Date'</span>)) res.setHeader(<span class="string">'Date'</span>, <span class="keyword">new</span> Date().toUTCString());
  <span class="keyword">if</span> (!res.getHeader(<span class="string">'Cache-Control'</span>)) res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'public, max-age='</span> + Math.floor(<span class="keyword">this</span>._maxage / <span class="number">1000</span>));

  <span class="keyword">if</span> (<span class="keyword">this</span>._lastModified &amp;&amp; !res.getHeader(<span class="string">'Last-Modified'</span>)) {
    <span class="keyword">var</span> modified = stat.mtime.toUTCString()
    debug(<span class="string">'modified %s'</span>, modified)
    res.setHeader(<span class="string">'Last-Modified'</span>, modified)
  }

  <span class="keyword">if</span> (<span class="keyword">this</span>._etag &amp;&amp; !res.getHeader(<span class="string">'ETag'</span>)) {
    <span class="keyword">var</span> val = etag(stat)
    debug(<span class="string">'etag %s'</span>, val)
    res.setHeader(<span class="string">'ETag'</span>, val)
  }
};

<span class="comment">/**
 * Determine if path parts contain a dotfile.
 *
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">containsDotFile</span><span class="params">(parts)</span> {</span>
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parts.length; i++) {
    <span class="keyword">if</span> (parts[i][<span class="number">0</span>] === <span class="string">'.'</span>) {
      <span class="keyword">return</span> <span class="literal">true</span>
    }
  }

  <span class="keyword">return</span> <span class="literal">false</span>
}

<span class="comment">/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all
 * of send().
 *
 * @param {String} path
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">decode</span><span class="params">(path)</span> {</span>
  <span class="keyword">try</span> {
    <span class="keyword">return</span> decodeURIComponent(path)
  } <span class="keyword">catch</span> (err) {
    <span class="keyword">return</span> -<span class="number">1</span>
  }
}

<span class="comment">/**
 * Normalize the index option into an array.
 *
 * @param {boolean|string|array} val
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">normalizeList</span><span class="params">(val)</span>{</span>
  <span class="keyword">return</span> [].concat(val || [])
}
</code></pre>