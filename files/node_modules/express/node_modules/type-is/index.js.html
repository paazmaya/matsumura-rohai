<h1>type-is</h1>
<pre><code class="lang-js"><span class="keyword">var</span> typer = require(<span class="string">'media-typer'</span>)
<span class="keyword">var</span> mime = require(<span class="string">'mime-types'</span>)

module.exports = typeofrequest;
typeofrequest.is = typeis;
typeofrequest.hasBody = hasbody;
typeofrequest.normalize = normalize;
typeofrequest.match = mimeMatch;

<span class="comment">/**
 * Compare a `value` content-type with `types`.
 * Each `type` can be an extension like `html`,
 * a special shortcut like `multipart` or `urlencoded`,
 * or a mime type.
 *
 * If no types match, `false` is returned.
 * Otherwise, the first `type` that matches is returned.
 *
 * @param {String} value
 * @param {Array} types
 * @return String
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">typeis</span><span class="params">(value, types_)</span> {</span>
  <span class="keyword">var</span> i
  <span class="keyword">var</span> types = types_

  <span class="comment">// remove parameters and normalize</span>
  value = typenormalize(value)

  <span class="comment">// no type or invalid</span>
  <span class="keyword">if</span> (!value) {
    <span class="keyword">return</span> <span class="literal">false</span>
  }

  <span class="comment">// support flattened arguments</span>
  <span class="keyword">if</span> (types &amp;&amp; !Array.isArray(types)) {
    types = <span class="keyword">new</span> Array(arguments.length - <span class="number">1</span>)
    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; types.length; i++) {
      types[i] = arguments[i + <span class="number">1</span>]
    }
  }

  <span class="comment">// no types, return the content type</span>
  <span class="keyword">if</span> (!types || !types.length) <span class="keyword">return</span> value;

  <span class="keyword">var</span> type
  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; types.length; i++) {
    <span class="keyword">if</span> (mimeMatch(normalize(type = types[i]), value)) {
      <span class="keyword">return</span> type[<span class="number">0</span>] === <span class="string">'+'</span> || ~type.indexOf(<span class="string">'*'</span>)
        ? value
        : type
    }
  }

  <span class="comment">// no matches</span>
  <span class="keyword">return</span> <span class="literal">false</span>;
}

<span class="comment">/**
 * Check if a request has a request body.
 * A request with a body __must__ either have `transfer-encoding`
 * or `content-length` headers set.
 * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3
 *
 * @param {Object} request
 * @return {Boolean}
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">hasbody</span><span class="params">(req)</span> {</span>
  <span class="keyword">var</span> headers = req.headers;
  <span class="keyword">if</span> (<span class="string">'transfer-encoding'</span> <span class="keyword">in</span> headers) <span class="keyword">return</span> <span class="literal">true</span>;
  <span class="keyword">return</span> !isNaN(headers[<span class="string">'content-length'</span>]);
}

<span class="comment">/**
 * Check if the incoming request contains the "Content-Type"
 * header field, and it contains any of the give mime `type`s.
 * If there is no request body, `null` is returned.
 * If there is no content type, `false` is returned.
 * Otherwise, it returns the first `type` that matches.
 *
 * Examples:
 *
 *     // With Content-Type: text/html; charset=utf-8
 *     this.is('html'); // => 'html'
 *     this.is('text/html'); // => 'text/html'
 *     this.is('text/*', 'application/json'); // => 'text/html'
 *
 *     // When Content-Type is application/json
 *     this.is('json', 'urlencoded'); // => 'json'
 *     this.is('application/json'); // => 'application/json'
 *     this.is('html', 'application/*'); // => 'application/json'
 *
 *     this.is('html'); // => false
 *
 * @param {String|Array} types...
 * @return {String|false|null}
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">typeofrequest</span><span class="params">(req, types_)</span> {</span>
  <span class="keyword">var</span> types = types_

  <span class="comment">// no body</span>
  <span class="keyword">if</span> (!hasbody(req)) {
    <span class="keyword">return</span> <span class="literal">null</span>
  }

  <span class="comment">// support flattened arguments</span>
  <span class="keyword">if</span> (arguments.length > <span class="number">2</span>) {
    types = <span class="keyword">new</span> Array(arguments.length - <span class="number">1</span>)
    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; types.length; i++) {
      types[i] = arguments[i + <span class="number">1</span>]
    }
  }

  <span class="comment">// request content type</span>
  <span class="keyword">var</span> value = req.headers[<span class="string">'content-type'</span>]

  <span class="keyword">return</span> typeis(value, types);
}

<span class="comment">/**
 * Normalize a mime type.
 * If it's a shorthand, expand it to a valid mime type.
 *
 * In general, you probably want:
 *
 *   var type = is(req, ['urlencoded', 'json', 'multipart']);
 *
 * Then use the appropriate body parsers.
 * These three are the most common request body types
 * and are thus ensured to work.
 *
 * @param {String} type
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">normalize</span><span class="params">(type)</span> {</span>
  <span class="keyword">switch</span> (type) {
    <span class="keyword">case</span> <span class="string">'urlencoded'</span>: <span class="keyword">return</span> <span class="string">'application/x-www-form-urlencoded'</span>;
    <span class="keyword">case</span> <span class="string">'multipart'</span>:
      type = <span class="string">'multipart/*'</span>;
      <span class="keyword">break</span>;
  }

  <span class="keyword">return</span> type[<span class="number">0</span>] === <span class="string">'+'</span> || ~type.indexOf(<span class="string">'/'</span>)
    ? type
    : mime.lookup(type)
}

<span class="comment">/**
 * Check if `exected` mime type
 * matches `actual` mime type with
 * wildcard and +suffix support.
 *
 * @param {String} expected
 * @param {String} actual
 * @return {Boolean}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">mimeMatch</span><span class="params">(expected, actual)</span> {</span>
  <span class="comment">// invalid type</span>
  <span class="keyword">if</span> (expected === <span class="literal">false</span>) {
    <span class="keyword">return</span> <span class="literal">false</span>
  }

  <span class="comment">// exact match</span>
  <span class="keyword">if</span> (expected === actual) {
    <span class="keyword">return</span> <span class="literal">true</span>
  }

  actual = actual.split(<span class="string">'/'</span>);

  <span class="keyword">if</span> (expected[<span class="number">0</span>] === <span class="string">'+'</span>) {
    <span class="comment">// support +suffix</span>
    <span class="keyword">return</span> Boolean(actual[<span class="number">1</span>])
      &amp;&amp; expected.length &lt;= actual[<span class="number">1</span>].length
      &amp;&amp; expected === actual[<span class="number">1</span>].substr(<span class="number">0</span> - expected.length)
  }

  <span class="keyword">if</span> (!~expected.indexOf(<span class="string">'*'</span>)) <span class="keyword">return</span> <span class="literal">false</span>;

  expected = expected.split(<span class="string">'/'</span>);

  <span class="keyword">if</span> (expected[<span class="number">0</span>] === <span class="string">'*'</span>) {
    <span class="comment">// support */yyy</span>
    <span class="keyword">return</span> expected[<span class="number">1</span>] === actual[<span class="number">1</span>]
  }

  <span class="keyword">if</span> (expected[<span class="number">1</span>] === <span class="string">'*'</span>) {
    <span class="comment">// support xxx/*</span>
    <span class="keyword">return</span> expected[<span class="number">0</span>] === actual[<span class="number">0</span>]
  }

  <span class="keyword">if</span> (expected[<span class="number">1</span>][<span class="number">0</span>] === <span class="string">'*'</span> &amp;&amp; expected[<span class="number">1</span>][<span class="number">1</span>] === <span class="string">'+'</span>) {
    <span class="comment">// support xxx/*+zzz</span>
    <span class="keyword">return</span> expected[<span class="number">0</span>] === actual[<span class="number">0</span>]
      &amp;&amp; expected[<span class="number">1</span>].length &lt;= actual[<span class="number">1</span>].length + <span class="number">1</span>
      &amp;&amp; expected[<span class="number">1</span>].substr(<span class="number">1</span>) === actual[<span class="number">1</span>].substr(<span class="number">1</span> - expected[<span class="number">1</span>].length)
  }

  <span class="keyword">return</span> <span class="literal">false</span>
}

<span class="comment">/**
 * Normalize a type and remove parameters.
 *
 * @param {string} value
 * @return {string}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">typenormalize</span><span class="params">(value)</span> {</span>
  <span class="keyword">try</span> {
    <span class="keyword">var</span> type = typer.parse(value)
    <span class="keyword">delete</span> type.parameters
    <span class="keyword">return</span> typer.format(type)
  } <span class="keyword">catch</span> (err) {
    <span class="keyword">return</span> <span class="literal">null</span>
  }
}
</code></pre>