<h1>ipaddr.js</h1>
<pre><code class="lang-js">(<span class="keyword">function</span>() {
  <span class="keyword">var</span> expandIPv6, ipaddr, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root;

  ipaddr = {};

  root = <span class="keyword">this</span>;

  <span class="keyword">if</span> ((<span class="keyword">typeof</span> module !== <span class="string">"undefined"</span> &amp;&amp; module !== <span class="literal">null</span>) &amp;&amp; module.exports) {
    module.exports = ipaddr;
  } <span class="keyword">else</span> {
    root[<span class="string">'ipaddr'</span>] = ipaddr;
  }

  matchCIDR = <span class="keyword">function</span>(first, second, partSize, cidrBits) {
    <span class="keyword">var</span> part, shift;
    <span class="keyword">if</span> (first.length !== second.length) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: cannot match CIDR for objects with different lengths"</span>);
    }
    part = <span class="number">0</span>;
    <span class="keyword">while</span> (cidrBits > <span class="number">0</span>) {
      shift = partSize - cidrBits;
      <span class="keyword">if</span> (shift &lt; <span class="number">0</span>) {
        shift = <span class="number">0</span>;
      }
      <span class="keyword">if</span> (first[part] >> shift !== second[part] >> shift) {
        <span class="keyword">return</span> <span class="literal">false</span>;
      }
      cidrBits -= partSize;
      part += <span class="number">1</span>;
    }
    <span class="keyword">return</span> <span class="literal">true</span>;
  };

  ipaddr.subnetMatch = <span class="keyword">function</span>(address, rangeList, defaultName) {
    <span class="keyword">var</span> rangeName, rangeSubnets, subnet, _i, _len;
    <span class="keyword">if</span> (defaultName == <span class="literal">null</span>) {
      defaultName = <span class="string">'unicast'</span>;
    }
    <span class="keyword">for</span> (rangeName <span class="keyword">in</span> rangeList) {
      rangeSubnets = rangeList[rangeName];
      <span class="keyword">if</span> (toString.call(rangeSubnets[<span class="number">0</span>]) !== <span class="string">'[object Array]'</span>) {
        rangeSubnets = [rangeSubnets];
      }
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = rangeSubnets.length; _i &lt; _len; _i++) {
        subnet = rangeSubnets[_i];
        <span class="keyword">if</span> (address.match.apply(address, subnet)) {
          <span class="keyword">return</span> rangeName;
        }
      }
    }
    <span class="keyword">return</span> defaultName;
  };

  ipaddr.IPv4 = (<span class="keyword">function</span>() {
    <span class="function"><span class="keyword">function</span> <span class="title">IPv4</span><span class="params">(octets)</span> {</span>
      <span class="keyword">var</span> octet, _i, _len;
      <span class="keyword">if</span> (octets.length !== <span class="number">4</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: ipv4 octet count should be 4"</span>);
      }
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = octets.length; _i &lt; _len; _i++) {
        octet = octets[_i];
        <span class="keyword">if</span> (!((<span class="number">0</span> &lt;= octet &amp;&amp; octet &lt;= <span class="number">255</span>))) {
          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: ipv4 octet is a byte"</span>);
        }
      }
      <span class="keyword">this</span>.octets = octets;
    }

    IPv4.prototype.kind = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">'ipv4'</span>;
    };

    IPv4.prototype.toString = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.octets.join(<span class="string">"."</span>);
    };

    IPv4.prototype.toByteArray = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.octets.slice(<span class="number">0</span>);
    };

    IPv4.prototype.match = <span class="keyword">function</span>(other, cidrRange) {
      <span class="keyword">if</span> (other.kind() !== <span class="string">'ipv4'</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: cannot match ipv4 address with non-ipv4 one"</span>);
      }
      <span class="keyword">return</span> matchCIDR(<span class="keyword">this</span>.octets, other.octets, <span class="number">8</span>, cidrRange);
    };

    IPv4.prototype.SpecialRanges = {
      broadcast: [[<span class="keyword">new</span> IPv4([<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>]), <span class="number">32</span>]],
      multicast: [[<span class="keyword">new</span> IPv4([<span class="number">224</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">4</span>]],
      linkLocal: [[<span class="keyword">new</span> IPv4([<span class="number">169</span>, <span class="number">254</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">16</span>]],
      loopback: [[<span class="keyword">new</span> IPv4([<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">8</span>]],
      <span class="string">"private"</span>: [[<span class="keyword">new</span> IPv4([<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">8</span>], [<span class="keyword">new</span> IPv4([<span class="number">172</span>, <span class="number">16</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">12</span>], [<span class="keyword">new</span> IPv4([<span class="number">192</span>, <span class="number">168</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">16</span>]],
      reserved: [[<span class="keyword">new</span> IPv4([<span class="number">192</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">24</span>], [<span class="keyword">new</span> IPv4([<span class="number">192</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>]), <span class="number">24</span>], [<span class="keyword">new</span> IPv4([<span class="number">192</span>, <span class="number">88</span>, <span class="number">99</span>, <span class="number">0</span>]), <span class="number">24</span>], [<span class="keyword">new</span> IPv4([<span class="number">198</span>, <span class="number">51</span>, <span class="number">100</span>, <span class="number">0</span>]), <span class="number">24</span>], [<span class="keyword">new</span> IPv4([<span class="number">203</span>, <span class="number">0</span>, <span class="number">113</span>, <span class="number">0</span>]), <span class="number">24</span>], [<span class="keyword">new</span> IPv4([<span class="number">240</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">4</span>]]
    };

    IPv4.prototype.range = <span class="keyword">function</span>() {
      <span class="keyword">return</span> ipaddr.subnetMatch(<span class="keyword">this</span>, <span class="keyword">this</span>.SpecialRanges);
    };

    IPv4.prototype.toIPv4MappedAddress = <span class="keyword">function</span>() {
      <span class="keyword">return</span> ipaddr.IPv6.parse(<span class="string">"::ffff:"</span> + (<span class="keyword">this</span>.toString()));
    };

    <span class="keyword">return</span> IPv4;

  })();

  ipv4Part = <span class="string">"(0?\\d+|0x[a-f0-9]+)"</span>;

  ipv4Regexes = {
    fourOctet: <span class="keyword">new</span> RegExp(<span class="string">"^"</span> + ipv4Part + <span class="string">"\\."</span> + ipv4Part + <span class="string">"\\."</span> + ipv4Part + <span class="string">"\\."</span> + ipv4Part + <span class="string">"$"</span>, <span class="string">'i'</span>),
    longValue: <span class="keyword">new</span> RegExp(<span class="string">"^"</span> + ipv4Part + <span class="string">"$"</span>, <span class="string">'i'</span>)
  };

  ipaddr.IPv4.parser = <span class="keyword">function</span>(string) {
    <span class="keyword">var</span> match, parseIntAuto, part, shift, value;
    parseIntAuto = <span class="keyword">function</span>(string) {
      <span class="keyword">if</span> (string[<span class="number">0</span>] === <span class="string">"0"</span> &amp;&amp; string[<span class="number">1</span>] !== <span class="string">"x"</span>) {
        <span class="keyword">return</span> parseInt(string, <span class="number">8</span>);
      } <span class="keyword">else</span> {
        <span class="keyword">return</span> parseInt(string);
      }
    };
    <span class="keyword">if</span> (match = string.match(ipv4Regexes.fourOctet)) {
      <span class="keyword">return</span> (<span class="keyword">function</span>() {
        <span class="keyword">var</span> _i, _len, _ref, _results;
        _ref = match.slice(<span class="number">1</span>, <span class="number">6</span>);
        _results = [];
        <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref.length; _i &lt; _len; _i++) {
          part = _ref[_i];
          _results.push(parseIntAuto(part));
        }
        <span class="keyword">return</span> _results;
      })();
    } <span class="keyword">else</span> <span class="keyword">if</span> (match = string.match(ipv4Regexes.longValue)) {
      value = parseIntAuto(match[<span class="number">1</span>]);
      <span class="keyword">return</span> ((<span class="keyword">function</span>() {
        <span class="keyword">var</span> _i, _results;
        _results = [];
        <span class="keyword">for</span> (shift = _i = <span class="number">0</span>; _i &lt;= <span class="number">24</span>; shift = _i += <span class="number">8</span>) {
          _results.push((value >> shift) &amp; <span class="number">0xff</span>);
        }
        <span class="keyword">return</span> _results;
      })()).reverse();
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
  };

  ipaddr.IPv6 = (<span class="keyword">function</span>() {
    <span class="function"><span class="keyword">function</span> <span class="title">IPv6</span><span class="params">(parts)</span> {</span>
      <span class="keyword">var</span> part, _i, _len;
      <span class="keyword">if</span> (parts.length !== <span class="number">8</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: ipv6 part count should be 8"</span>);
      }
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = parts.length; _i &lt; _len; _i++) {
        part = parts[_i];
        <span class="keyword">if</span> (!((<span class="number">0</span> &lt;= part &amp;&amp; part &lt;= <span class="number">0xffff</span>))) {
          <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: ipv6 part should fit to two octets"</span>);
        }
      }
      <span class="keyword">this</span>.parts = parts;
    }

    IPv6.prototype.kind = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="string">'ipv6'</span>;
    };

    IPv6.prototype.toString = <span class="keyword">function</span>() {
      <span class="keyword">var</span> compactStringParts, part, pushPart, state, stringParts, _i, _len;
      stringParts = (<span class="keyword">function</span>() {
        <span class="keyword">var</span> _i, _len, _ref, _results;
        _ref = <span class="keyword">this</span>.parts;
        _results = [];
        <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref.length; _i &lt; _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(<span class="number">16</span>));
        }
        <span class="keyword">return</span> _results;
      }).call(<span class="keyword">this</span>);
      compactStringParts = [];
      pushPart = <span class="keyword">function</span>(part) {
        <span class="keyword">return</span> compactStringParts.push(part);
      };
      state = <span class="number">0</span>;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = stringParts.length; _i &lt; _len; _i++) {
        part = stringParts[_i];
        <span class="keyword">switch</span> (state) {
          <span class="keyword">case</span> <span class="number">0</span>:
            <span class="keyword">if</span> (part === <span class="string">'0'</span>) {
              pushPart(<span class="string">''</span>);
            } <span class="keyword">else</span> {
              pushPart(part);
            }
            state = <span class="number">1</span>;
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="number">1</span>:
            <span class="keyword">if</span> (part === <span class="string">'0'</span>) {
              state = <span class="number">2</span>;
            } <span class="keyword">else</span> {
              pushPart(part);
            }
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="number">2</span>:
            <span class="keyword">if</span> (part !== <span class="string">'0'</span>) {
              pushPart(<span class="string">''</span>);
              pushPart(part);
              state = <span class="number">3</span>;
            }
            <span class="keyword">break</span>;
          <span class="keyword">case</span> <span class="number">3</span>:
            pushPart(part);
        }
      }
      <span class="keyword">if</span> (state === <span class="number">2</span>) {
        pushPart(<span class="string">''</span>);
        pushPart(<span class="string">''</span>);
      }
      <span class="keyword">return</span> compactStringParts.join(<span class="string">":"</span>);
    };

    IPv6.prototype.toByteArray = <span class="keyword">function</span>() {
      <span class="keyword">var</span> bytes, part, _i, _len, _ref;
      bytes = [];
      _ref = <span class="keyword">this</span>.parts;
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref.length; _i &lt; _len; _i++) {
        part = _ref[_i];
        bytes.push(part >> <span class="number">8</span>);
        bytes.push(part &amp; <span class="number">0xff</span>);
      }
      <span class="keyword">return</span> bytes;
    };

    IPv6.prototype.toNormalizedString = <span class="keyword">function</span>() {
      <span class="keyword">var</span> part;
      <span class="keyword">return</span> ((<span class="keyword">function</span>() {
        <span class="keyword">var</span> _i, _len, _ref, _results;
        _ref = <span class="keyword">this</span>.parts;
        _results = [];
        <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref.length; _i &lt; _len; _i++) {
          part = _ref[_i];
          _results.push(part.toString(<span class="number">16</span>));
        }
        <span class="keyword">return</span> _results;
      }).call(<span class="keyword">this</span>)).join(<span class="string">":"</span>);
    };

    IPv6.prototype.match = <span class="keyword">function</span>(other, cidrRange) {
      <span class="keyword">if</span> (other.kind() !== <span class="string">'ipv6'</span>) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: cannot match ipv6 address with non-ipv6 one"</span>);
      }
      <span class="keyword">return</span> matchCIDR(<span class="keyword">this</span>.parts, other.parts, <span class="number">16</span>, cidrRange);
    };

    IPv6.prototype.SpecialRanges = {
      unspecified: [<span class="keyword">new</span> IPv6([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">128</span>],
      linkLocal: [<span class="keyword">new</span> IPv6([<span class="number">0xfe80</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">10</span>],
      multicast: [<span class="keyword">new</span> IPv6([<span class="number">0xff00</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">8</span>],
      loopback: [<span class="keyword">new</span> IPv6([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]), <span class="number">128</span>],
      uniqueLocal: [<span class="keyword">new</span> IPv6([<span class="number">0xfc00</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">7</span>],
      ipv4Mapped: [<span class="keyword">new</span> IPv6([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">96</span>],
      rfc6145: [<span class="keyword">new</span> IPv6([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xffff</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">96</span>],
      rfc6052: [<span class="keyword">new</span> IPv6([<span class="number">0x64</span>, <span class="number">0xff9b</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">96</span>],
      <span class="string">'6to4'</span>: [<span class="keyword">new</span> IPv6([<span class="number">0x2002</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">16</span>],
      teredo: [<span class="keyword">new</span> IPv6([<span class="number">0x2001</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">32</span>],
      reserved: [[<span class="keyword">new</span> IPv6([<span class="number">0x2001</span>, <span class="number">0xdb8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]), <span class="number">32</span>]]
    };

    IPv6.prototype.range = <span class="keyword">function</span>() {
      <span class="keyword">return</span> ipaddr.subnetMatch(<span class="keyword">this</span>, <span class="keyword">this</span>.SpecialRanges);
    };

    IPv6.prototype.isIPv4MappedAddress = <span class="keyword">function</span>() {
      <span class="keyword">return</span> <span class="keyword">this</span>.range() === <span class="string">'ipv4Mapped'</span>;
    };

    IPv6.prototype.toIPv4Address = <span class="keyword">function</span>() {
      <span class="keyword">var</span> high, low, _ref;
      <span class="keyword">if</span> (!<span class="keyword">this</span>.isIPv4MappedAddress()) {
        <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: trying to convert a generic ipv6 address to ipv4"</span>);
      }
      _ref = <span class="keyword">this</span>.parts.slice(-<span class="number">2</span>), high = _ref[<span class="number">0</span>], low = _ref[<span class="number">1</span>];
      <span class="keyword">return</span> <span class="keyword">new</span> ipaddr.IPv4([high >> <span class="number">8</span>, high &amp; <span class="number">0xff</span>, low >> <span class="number">8</span>, low &amp; <span class="number">0xff</span>]);
    };

    <span class="keyword">return</span> IPv6;

  })();

  ipv6Part = <span class="string">"(?:[0-9a-f]+::?)+"</span>;

  ipv6Regexes = {
    <span class="string">"native"</span>: <span class="keyword">new</span> RegExp(<span class="string">"^(::)?("</span> + ipv6Part + <span class="string">")?([0-9a-f]+)?(::)?$"</span>, <span class="string">'i'</span>),
    transitional: <span class="keyword">new</span> RegExp((<span class="string">"^((?:"</span> + ipv6Part + <span class="string">")|(?:::)(?:"</span> + ipv6Part + <span class="string">")?)"</span>) + (<span class="string">""</span> + ipv4Part + <span class="string">"\\."</span> + ipv4Part + <span class="string">"\\."</span> + ipv4Part + <span class="string">"\\."</span> + ipv4Part + <span class="string">"$"</span>), <span class="string">'i'</span>)
  };

  expandIPv6 = <span class="keyword">function</span>(string, parts) {
    <span class="keyword">var</span> colonCount, lastColon, part, replacement, replacementCount;
    <span class="keyword">if</span> (string.indexOf(<span class="string">'::'</span>) !== string.lastIndexOf(<span class="string">'::'</span>)) {
      <span class="keyword">return</span> <span class="literal">null</span>;
    }
    colonCount = <span class="number">0</span>;
    lastColon = -<span class="number">1</span>;
    <span class="keyword">while</span> ((lastColon = string.indexOf(<span class="string">':'</span>, lastColon + <span class="number">1</span>)) >= <span class="number">0</span>) {
      colonCount++;
    }
    <span class="keyword">if</span> (string[<span class="number">0</span>] === <span class="string">':'</span>) {
      colonCount--;
    }
    <span class="keyword">if</span> (string[string.length - <span class="number">1</span>] === <span class="string">':'</span>) {
      colonCount--;
    }
    replacementCount = parts - colonCount;
    replacement = <span class="string">':'</span>;
    <span class="keyword">while</span> (replacementCount--) {
      replacement += <span class="string">'0:'</span>;
    }
    string = string.replace(<span class="string">'::'</span>, replacement);
    <span class="keyword">if</span> (string[<span class="number">0</span>] === <span class="string">':'</span>) {
      string = string.slice(<span class="number">1</span>);
    }
    <span class="keyword">if</span> (string[string.length - <span class="number">1</span>] === <span class="string">':'</span>) {
      string = string.slice(<span class="number">0</span>, -<span class="number">1</span>);
    }
    <span class="keyword">return</span> (<span class="keyword">function</span>() {
      <span class="keyword">var</span> _i, _len, _ref, _results;
      _ref = string.split(<span class="string">":"</span>);
      _results = [];
      <span class="keyword">for</span> (_i = <span class="number">0</span>, _len = _ref.length; _i &lt; _len; _i++) {
        part = _ref[_i];
        _results.push(parseInt(part, <span class="number">16</span>));
      }
      <span class="keyword">return</span> _results;
    })();
  };

  ipaddr.IPv6.parser = <span class="keyword">function</span>(string) {
    <span class="keyword">var</span> match, parts;
    <span class="keyword">if</span> (string.match(ipv6Regexes[<span class="string">'native'</span>])) {
      <span class="keyword">return</span> expandIPv6(string, <span class="number">8</span>);
    } <span class="keyword">else</span> <span class="keyword">if</span> (match = string.match(ipv6Regexes[<span class="string">'transitional'</span>])) {
      parts = expandIPv6(match[<span class="number">1</span>].slice(<span class="number">0</span>, -<span class="number">1</span>), <span class="number">6</span>);
      <span class="keyword">if</span> (parts) {
        parts.push(parseInt(match[<span class="number">2</span>]) &lt;&lt; <span class="number">8</span> | parseInt(match[<span class="number">3</span>]));
        parts.push(parseInt(match[<span class="number">4</span>]) &lt;&lt; <span class="number">8</span> | parseInt(match[<span class="number">5</span>]));
        <span class="keyword">return</span> parts;
      }
    }
    <span class="keyword">return</span> <span class="literal">null</span>;
  };

  ipaddr.IPv4.isIPv4 = ipaddr.IPv6.isIPv6 = <span class="keyword">function</span>(string) {
    <span class="keyword">return</span> <span class="keyword">this</span>.parser(string) !== <span class="literal">null</span>;
  };

  ipaddr.IPv4.isValid = ipaddr.IPv6.isValid = <span class="keyword">function</span>(string) {
    <span class="keyword">var</span> e;
    <span class="keyword">try</span> {
      <span class="keyword">new</span> <span class="keyword">this</span>(<span class="keyword">this</span>.parser(string));
      <span class="keyword">return</span> <span class="literal">true</span>;
    } <span class="keyword">catch</span> (_error) {
      e = _error;
      <span class="keyword">return</span> <span class="literal">false</span>;
    }
  };

  ipaddr.IPv4.parse = ipaddr.IPv6.parse = <span class="keyword">function</span>(string) {
    <span class="keyword">var</span> parts;
    parts = <span class="keyword">this</span>.parser(string);
    <span class="keyword">if</span> (parts === <span class="literal">null</span>) {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: string is not formatted like ip address"</span>);
    }
    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">this</span>(parts);
  };

  ipaddr.isValid = <span class="keyword">function</span>(string) {
    <span class="keyword">return</span> ipaddr.IPv6.isValid(string) || ipaddr.IPv4.isValid(string);
  };

  ipaddr.parse = <span class="keyword">function</span>(string) {
    <span class="keyword">if</span> (ipaddr.IPv6.isIPv6(string)) {
      <span class="keyword">return</span> ipaddr.IPv6.parse(string);
    } <span class="keyword">else</span> <span class="keyword">if</span> (ipaddr.IPv4.isIPv4(string)) {
      <span class="keyword">return</span> ipaddr.IPv4.parse(string);
    } <span class="keyword">else</span> {
      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"ipaddr: the address has neither IPv6 nor IPv4 format"</span>);
    }
  };

  ipaddr.process = <span class="keyword">function</span>(string) {
    <span class="keyword">var</span> addr;
    addr = <span class="keyword">this</span>.parse(string);
    <span class="keyword">if</span> (addr.kind() === <span class="string">'ipv6'</span> &amp;&amp; addr.isIPv4MappedAddress()) {
      <span class="keyword">return</span> addr.toIPv4Address();
    } <span class="keyword">else</span> {
      <span class="keyword">return</span> addr;
    }
  };

}).call(<span class="keyword">this</span>);
</code></pre>