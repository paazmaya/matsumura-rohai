<h1>proxy-addr</h1>
<pre><code class="lang-js"><span class="comment">/*!
 * proxy-addr
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */</span>

<span class="comment">/**
 * Module exports.
 */</span>

module.exports = proxyaddr;
module.exports.all = alladdrs;
module.exports.compile = compile;

<span class="comment">/**
 * Module dependencies.
 */</span>

<span class="keyword">var</span> forwarded = require(<span class="string">'forwarded'</span>);
<span class="keyword">var</span> ipaddr = require(<span class="string">'ipaddr.js'</span>);

<span class="comment">/**
 * Variables.
 */</span>

<span class="keyword">var</span> digitre = <span class="regexp">/^[0-9]+$/</span>;
<span class="keyword">var</span> isip = ipaddr.isValid;
<span class="keyword">var</span> parseip = ipaddr.parse;

<span class="comment">/**
 * Pre-defined IP ranges.
 */</span>

<span class="keyword">var</span> ipranges = {
  linklocal: [<span class="string">'169.254.0.0/16'</span>, <span class="string">'fe80::/10'</span>],
  loopback: [<span class="string">'127.0.0.1/8'</span>, <span class="string">'::1/128'</span>],
  uniquelocal: [<span class="string">'10.0.0.0/8'</span>, <span class="string">'172.16.0.0/12'</span>, <span class="string">'192.168.0.0/16'</span>, <span class="string">'fc00::/7'</span>]
};

<span class="comment">/**
 * Get all addresses in the request, optionally stopping
 * at the first untrusted.
 *
 * @param {Object} request
 * @param {Function|Array|String} [trust]
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">alladdrs</span><span class="params">(req, trust)</span> {</span>
  <span class="comment">// get addresses</span>
  <span class="keyword">var</span> addrs = forwarded(req);

  <span class="keyword">if</span> (!trust) {
    <span class="comment">// Return all addresses</span>
    <span class="keyword">return</span> addrs;
  }

  <span class="keyword">if</span> (<span class="keyword">typeof</span> trust !== <span class="string">'function'</span>) {
    trust = compile(trust);
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; addrs.length - <span class="number">1</span>; i++) {
    <span class="keyword">if</span> (trust(addrs[i], i)) <span class="keyword">continue</span>;

    addrs.length = i + <span class="number">1</span>;
  }

  <span class="keyword">return</span> addrs;
}

<span class="comment">/**
 * Compile argument into trust function.
 *
 * @param {Array|String} val
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">compile</span><span class="params">(val)</span> {</span>
  <span class="keyword">if</span> (!val) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'argument is required'</span>);
  }

  <span class="keyword">var</span> trust = <span class="keyword">typeof</span> val === <span class="string">'string'</span>
    ? [val]
    : val;

  <span class="keyword">if</span> (!Array.isArray(trust)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'unsupported trust argument'</span>);
  }

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; trust.length; i++) {
    val = trust[i];

    <span class="keyword">if</span> (!ipranges.hasOwnProperty(val)) {
      <span class="keyword">continue</span>;
    }

    <span class="comment">// Splice in pre-defined range</span>
    val = ipranges[val];
    trust.splice.apply(trust, [i, <span class="number">1</span>].concat(val));
    i += val.length - <span class="number">1</span>;
  }

  <span class="keyword">return</span> compileTrust(compileRangeSubnets(trust));
}

<span class="comment">/**
 * Compile `arr` elements into range subnets.
 *
 * @param {Array} arr
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">compileRangeSubnets</span><span class="params">(arr)</span> {</span>
  <span class="keyword">var</span> rangeSubnets = <span class="keyword">new</span> Array(arr.length);

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i]);
  }

  <span class="keyword">return</span> rangeSubnets;
}

<span class="comment">/**
 * Compile range subnet array into trust function.
 *
 * @param {Array} rangeSubnets
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">compileTrust</span><span class="params">(rangeSubnets)</span> {</span>
  <span class="comment">// Return optimized function based on length</span>
  <span class="keyword">var</span> len = rangeSubnets.length;
  <span class="keyword">return</span> len === <span class="number">0</span>
    ? trustNone
    : len === <span class="number">1</span>
    ? trustSingle(rangeSubnets[<span class="number">0</span>])
    : trustMulti(rangeSubnets);
}

<span class="comment">/**
 * Parse IP notation string into range subnet.
 *
 * @param {String} note
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">parseipNotation</span><span class="params">(note)</span> {</span>
  <span class="keyword">var</span> ip;
  <span class="keyword">var</span> kind;
  <span class="keyword">var</span> max;
  <span class="keyword">var</span> pos = note.lastIndexOf(<span class="string">'/'</span>);
  <span class="keyword">var</span> range;

  ip = pos !== -<span class="number">1</span>
    ? note.substring(<span class="number">0</span>, pos)
    : note;

  <span class="keyword">if</span> (!isip(ip)) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'invalid IP address: '</span> + ip);
  }

  ip = parseip(ip);

  kind = ip.kind();
  max = kind === <span class="string">'ipv6'</span>
    ? <span class="number">128</span>
    : <span class="number">32</span>;

  range = pos !== -<span class="number">1</span>
    ? note.substring(pos + <span class="number">1</span>, note.length)
    : max;

  <span class="keyword">if</span> (<span class="keyword">typeof</span> range !== <span class="string">'number'</span>) {
    range = digitre.test(range)
      ? parseInt(range, <span class="number">10</span>)
      : isip(range)
      ? parseNetmask(range)
      : <span class="number">0</span>;
  }

  <span class="keyword">if</span> (ip.kind() === <span class="string">'ipv6'</span> &amp;&amp; ip.isIPv4MappedAddress()) {
    <span class="comment">// Store as IPv4</span>
    ip = ip.toIPv4Address();
    range = range &lt;= max
      ? range - <span class="number">96</span>
      : range;
  }

  <span class="keyword">if</span> (range &lt;= <span class="number">0</span> || range > max) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'invalid range on address: '</span> + note);
  }

  <span class="keyword">return</span> [ip, range];
}

<span class="comment">/**
 * Parse netmask string into CIDR range.
 *
 * @param {String} note
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">parseNetmask</span><span class="params">(netmask)</span> {</span>
  <span class="keyword">var</span> ip = parseip(netmask);
  <span class="keyword">var</span> parts;
  <span class="keyword">var</span> size;

  <span class="keyword">switch</span> (ip.kind()) {
    <span class="keyword">case</span> <span class="string">'ipv4'</span>:
      parts = ip.octets;
      size = <span class="number">8</span>;
      <span class="keyword">break</span>;
    <span class="keyword">case</span> <span class="string">'ipv6'</span>:
      parts = ip.parts;
      size = <span class="number">16</span>;
      <span class="keyword">break</span>;
  }

  <span class="keyword">var</span> max = Math.pow(<span class="number">2</span>, size) - <span class="number">1</span>;
  <span class="keyword">var</span> part;
  <span class="keyword">var</span> range = <span class="number">0</span>;

  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; parts.length; i++) {
    part = parts[i] &amp; max;

    <span class="keyword">if</span> (part === max) {
      range += size;
      <span class="keyword">continue</span>;
    }

    <span class="keyword">while</span> (part) {
      part = (part &lt;&lt; <span class="number">1</span>) &amp; max;
      range += <span class="number">1</span>;
    }

    <span class="keyword">break</span>;
  }

  <span class="keyword">return</span> range;
}

<span class="comment">/**
 * Determine address of proxied request.
 *
 * @param {Object} request
 * @param {Function|Array|String} trust
 * @api public
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">proxyaddr</span><span class="params">(req, trust)</span> {</span>
  <span class="keyword">if</span> (!req) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'req argument is required'</span>);
  }

  <span class="keyword">if</span> (!trust) {
    <span class="keyword">throw</span> <span class="keyword">new</span> TypeError(<span class="string">'trust argument is required'</span>);
  }

  <span class="keyword">var</span> addrs = alladdrs(req, trust);
  <span class="keyword">var</span> addr = addrs[addrs.length - <span class="number">1</span>];

  <span class="keyword">return</span> addr;
}

<span class="comment">/**
 * Static trust function to trust nothing.
 *
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">trustNone</span><span class="params">()</span> {</span>
  <span class="keyword">return</span> <span class="literal">false</span>;
}

<span class="comment">/**
 * Compile trust function for multiple subnets.
 *
 * @param {Array} subnets
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">trustMulti</span><span class="params">(subnets)</span> {</span>
  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">trust</span><span class="params">(addr)</span> {</span>
    <span class="keyword">if</span> (!isip(addr)) <span class="keyword">return</span> <span class="literal">false</span>;

    <span class="keyword">var</span> ip = parseip(addr);
    <span class="keyword">var</span> ipv4;
    <span class="keyword">var</span> kind = ip.kind();
    <span class="keyword">var</span> subnet;
    <span class="keyword">var</span> subnetip;
    <span class="keyword">var</span> subnetkind;
    <span class="keyword">var</span> subnetrange;
    <span class="keyword">var</span> trusted;

    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; subnets.length; i++) {
      subnet = subnets[i];
      subnetip = subnet[<span class="number">0</span>];
      subnetkind = subnetip.kind();
      subnetrange = subnet[<span class="number">1</span>];
      trusted = ip;

      <span class="keyword">if</span> (kind !== subnetkind) {
        <span class="keyword">if</span> (kind !== <span class="string">'ipv6'</span> || subnetkind !== <span class="string">'ipv4'</span> || !ip.isIPv4MappedAddress()) {
          <span class="keyword">continue</span>;
        }

        <span class="comment">// Store addr as IPv4</span>
        ipv4 = ipv4 || ip.toIPv4Address();
        trusted = ipv4;
      }

      <span class="keyword">if</span> (trusted.match(subnetip, subnetrange)) <span class="keyword">return</span> <span class="literal">true</span>;
    }

    <span class="keyword">return</span> <span class="literal">false</span>;
  };
}

<span class="comment">/**
 * Compile trust function for single subnet.
 *
 * @param {Object} subnet
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">trustSingle</span><span class="params">(subnet)</span> {</span>
  <span class="keyword">var</span> subnetip = subnet[<span class="number">0</span>];
  <span class="keyword">var</span> subnetkind = subnetip.kind();
  <span class="keyword">var</span> subnetisipv4 = subnetkind === <span class="string">'ipv4'</span>;
  <span class="keyword">var</span> subnetrange = subnet[<span class="number">1</span>];

  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">trust</span><span class="params">(addr)</span> {</span>
    <span class="keyword">if</span> (!isip(addr)) <span class="keyword">return</span> <span class="literal">false</span>;

    <span class="keyword">var</span> ip = parseip(addr);
    <span class="keyword">var</span> kind = ip.kind();

    <span class="keyword">return</span> kind === subnetkind
      ? ip.match(subnetip, subnetrange)
      : subnetisipv4 &amp;&amp; kind === <span class="string">'ipv6'</span> &amp;&amp; ip.isIPv4MappedAddress()
      ? ip.toIPv4Address().match(subnetip, subnetrange)
      : <span class="literal">false</span>;
  };
}
</code></pre>