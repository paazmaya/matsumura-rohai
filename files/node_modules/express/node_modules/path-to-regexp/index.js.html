<h1>path-to-regexp</h1>
<pre><code class="lang-js"><span class="comment">/**
 * Expose `pathtoRegexp`.
 */</span>

module.exports = pathtoRegexp;

<span class="comment">/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Object} options
 * @return {RegExp}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">pathtoRegexp</span><span class="params">(path, keys, options)</span> {</span>
  options = options || {};
  <span class="keyword">var</span> strict = options.strict;
  <span class="keyword">var</span> end = options.end !== <span class="literal">false</span>;
  <span class="keyword">var</span> flags = options.sensitive ? <span class="string">''</span> : <span class="string">'i'</span>;
  keys = keys || [];

  <span class="keyword">if</span> (path <span class="keyword">instanceof</span> RegExp) {
    <span class="keyword">return</span> path;
  }

  <span class="keyword">if</span> (Array.isArray(path)) {
    <span class="comment">// Map array parts into regexps and return their source. We also pass</span>
    <span class="comment">// the same keys and options instance into every generation to get</span>
    <span class="comment">// consistent matching groups before we join the sources together.</span>
    path = path.map(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> {</span>
      <span class="keyword">return</span> pathtoRegexp(value, keys, options).source;
    });

    <span class="keyword">return</span> <span class="keyword">new</span> RegExp(<span class="string">'(?:'</span> + path.join(<span class="string">'|'</span>) + <span class="string">')'</span>, flags);
  }

  path = (<span class="string">'^'</span> + path + (strict ? <span class="string">''</span> : path[path.length - <span class="number">1</span>] === <span class="string">'/'</span> ? <span class="string">'?'</span> : <span class="string">'/?'</span>))
    .replace(<span class="regexp">/\/\(/g</span>, <span class="string">'/(?:'</span>)
    .replace(<span class="regexp">/([\/\.])/g</span>, <span class="string">'\\$1'</span>)
    .replace(<span class="regexp">/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g</span>, <span class="function"><span class="keyword">function</span> <span class="params">(match, slash, format, key, capture, star, optional)</span> {</span>
      slash = slash || <span class="string">''</span>;
      format = format || <span class="string">''</span>;
      capture = capture || <span class="string">'([^\\/'</span> + format + <span class="string">']+?)'</span>;
      optional = optional || <span class="string">''</span>;

      keys.push({ name: key, optional: !!optional });

      <span class="keyword">return</span> <span class="string">''</span>
        + (optional ? <span class="string">''</span> : slash)
        + <span class="string">'(?:'</span>
        + format + (optional ? slash : <span class="string">''</span>) + capture
        + (star ? <span class="string">'((?:[\\/'</span> + format + <span class="string">'].+?)?)'</span> : <span class="string">''</span>)
        + <span class="string">')'</span>
        + optional;
    })
    .replace(<span class="regexp">/\*/g</span>, <span class="string">'(.*)'</span>);

  <span class="comment">// If the path is non-ending, match until the end or a slash.</span>
  path += (end ? <span class="string">'$'</span> : (path[path.length - <span class="number">1</span>] === <span class="string">'/'</span> ? <span class="string">''</span> : <span class="string">'(?=\\/|$)'</span>));

  <span class="keyword">return</span> <span class="keyword">new</span> RegExp(path, flags);
};
</code></pre>