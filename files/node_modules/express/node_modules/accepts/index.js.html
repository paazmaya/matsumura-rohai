<h1>accepts</h1>
<pre><code class="lang-js"><span class="keyword">var</span> Negotiator = require(<span class="string">'negotiator'</span>)
<span class="keyword">var</span> mime = require(<span class="string">'mime-types'</span>)

<span class="keyword">var</span> slice = [].slice

module.exports = Accepts

<span class="function"><span class="keyword">function</span> <span class="title">Accepts</span><span class="params">(req)</span> {</span>
  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Accepts))
    <span class="keyword">return</span> <span class="keyword">new</span> Accepts(req)

  <span class="keyword">this</span>.headers = req.headers
  <span class="keyword">this</span>.negotiator = Negotiator(req)
}

<span class="comment">/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} type(s)...
 * @return {String|Array|Boolean}
 * @api public
 */</span>

Accepts.prototype.type =
Accepts.prototype.types = <span class="function"><span class="keyword">function</span> <span class="params">(types)</span> {</span>
  <span class="keyword">if</span> (!Array.isArray(types)) types = slice.call(arguments);
  <span class="keyword">var</span> n = <span class="keyword">this</span>.negotiator;
  <span class="keyword">if</span> (!types.length) <span class="keyword">return</span> n.mediaTypes();
  <span class="keyword">if</span> (!<span class="keyword">this</span>.headers.accept) <span class="keyword">return</span> types[<span class="number">0</span>];
  <span class="keyword">var</span> mimes = types.map(extToMime);
  <span class="keyword">var</span> accepts = n.mediaTypes(mimes.filter(validMime));
  <span class="keyword">var</span> first = accepts[<span class="number">0</span>];
  <span class="keyword">if</span> (!first) <span class="keyword">return</span> <span class="literal">false</span>;
  <span class="keyword">return</span> types[mimes.indexOf(first)];
}

<span class="comment">/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encoding(s)...
 * @return {String|Array}
 * @api public
 */</span>

Accepts.prototype.encoding =
Accepts.prototype.encodings = <span class="function"><span class="keyword">function</span> <span class="params">(encodings)</span> {</span>
  <span class="keyword">if</span> (!Array.isArray(encodings)) encodings = slice.call(arguments);
  <span class="keyword">var</span> n = <span class="keyword">this</span>.negotiator;
  <span class="keyword">if</span> (!encodings.length) <span class="keyword">return</span> n.encodings();
  <span class="keyword">return</span> n.encodings(encodings)[<span class="number">0</span>] || <span class="literal">false</span>;
}

<span class="comment">/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charset(s)...
 * @return {String|Array}
 * @api public
 */</span>

Accepts.prototype.charset =
Accepts.prototype.charsets = <span class="function"><span class="keyword">function</span> <span class="params">(charsets)</span> {</span>
  <span class="keyword">if</span> (!Array.isArray(charsets)) charsets = [].slice.call(arguments);
  <span class="keyword">var</span> n = <span class="keyword">this</span>.negotiator;
  <span class="keyword">if</span> (!charsets.length) <span class="keyword">return</span> n.charsets();
  <span class="keyword">if</span> (!<span class="keyword">this</span>.headers[<span class="string">'accept-charset'</span>]) <span class="keyword">return</span> charsets[<span class="number">0</span>];
  <span class="keyword">return</span> n.charsets(charsets)[<span class="number">0</span>] || <span class="literal">false</span>;
}

<span class="comment">/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} lang(s)...
 * @return {Array|String}
 * @api public
 */</span>

Accepts.prototype.lang =
Accepts.prototype.langs =
Accepts.prototype.language =
Accepts.prototype.languages = <span class="function"><span class="keyword">function</span> <span class="params">(langs)</span> {</span>
  <span class="keyword">if</span> (!Array.isArray(langs)) langs = slice.call(arguments);
  <span class="keyword">var</span> n = <span class="keyword">this</span>.negotiator;
  <span class="keyword">if</span> (!langs.length) <span class="keyword">return</span> n.languages();
  <span class="keyword">if</span> (!<span class="keyword">this</span>.headers[<span class="string">'accept-language'</span>]) <span class="keyword">return</span> langs[<span class="number">0</span>];
  <span class="keyword">return</span> n.languages(langs)[<span class="number">0</span>] || <span class="literal">false</span>;
}

<span class="comment">/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">extToMime</span><span class="params">(type)</span> {</span>
  <span class="keyword">if</span> (~type.indexOf(<span class="string">'/'</span>)) <span class="keyword">return</span> type;
  <span class="keyword">return</span> mime.lookup(type);
}

<span class="comment">/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @api private
 */</span>

<span class="function"><span class="keyword">function</span> <span class="title">validMime</span><span class="params">(type)</span> {</span>
  <span class="keyword">return</span> <span class="keyword">typeof</span> type === <span class="string">'string'</span>;
}
</code></pre>